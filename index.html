<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>AI Hockey Unified - Full Rink</title>
<style>
    body {
        background:#111;
        margin:0;
        overflow:hidden;
    }
    canvas {
        background:#000;
        display:block;
        margin:0 auto;
    }
</style>
</head>

<body>
<canvas id="game" width="1000" height="600"></canvas>


<script>
// =========================================================
// BASIC SETUP
// =========================================================

let menuIndex = 0;
const menuItems = ["New Game", "Options", "Exit"];


const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let TRAINING_MODE = false;

// === NEW GAME STATE GLOBALS ===
let gameState = 'menu'; // 'menu', 'playing', or 'training'
let trainingTimeoutId = null; // To track and stop the fast loop
// ==============================

// =========================================================
// TRAINING GLOBALS (Phase 2)
// =========================================================
let TRAIN_RENDER = true;          // toggle rendering
let TRAIN_STEPS = 0;              // total training steps
let TRAIN_EPISODES = 0;           // completed training episodes
let TRAIN_LAST_TIME = performance.now();
let TRAIN_SPS = 0;                // steps per second measurement
let TRAIN_LAST_TIME_STEPS = 0;
let TRAIN_EPISODE_ACTIVE = true;
let WATCH_MODE = false;

// =========================================================
// GOAL-BASED EPISODE METRICS
// =========================================================
let TRAIN_TOTAL_GOALS = 0;

let TRAIN_POS_T0 = 0;    // possession time team 0
let TRAIN_POS_T1 = 0;    // possession time team 1
let TRAIN_POS_NONE = 0;  // puck free time

const TRAIN_GOALS_PER_EPISODE = 11;

// =========================================================
// TRAINING EPISODE RESET
// =========================================================
function resetTrainingEpisode() {
   

    // Reset puck
    puck.x = RX;
    puck.y = RY;
    puck.vx = 0;
    puck.vy = 0;
    puck.ownerId = null;

    // Reset players
    for (const p of players) {
        if (p.team === 0) {
            p.x = RX - 60;
            p.angle = 0;
        } else {
            p.x = RX + 60;
            p.angle = Math.PI;
        }

        p.vx = 0;
        p.vy = 0;
        p.reward = 0;  // clear reward for new episode
    }
}

// =========================================================
// TRAINING REWARDS (Phase 3)
// =========================================================
function applyTrainingRewards() {
    const owner = getPlayerById(puck.ownerId);

    for (const p of players) {

        // <<< ONLY TEAM 0 LEARNS >>>
        if (p.team !== 0) continue;

        let r = 0;

        // =====================================================
        // 1. Reward: moving toward the puck
        // =====================================================
        const dxp = puck.x - p.x;
        const dyp = puck.y - p.y;
        const dot = (p.vx * dxp + p.vy * dyp);

        if (dot > 0) r += 0.01;
        else r -= 0.02;

        // =====================================================
        // 2. Reward: possession
        // =====================================================
        if (owner && owner.id === p.id) r += 0.1;

        // =====================================================
        // 3. Reward: team scoring
        // =====================================================
        if (lastGoalTeam !== null && lastGoalTeam === p.team) r += 1.0;

        // =====================================================
        // 4. Penalty: crowding / clustering
        // =====================================================
        for (const o of players) {
            if (o === p) continue;
            const d = Math.hypot(p.x - o.x, p.y - o.y);

            // discourage tight huddles
            if (d < 25) r -= 0.03;
        }

        // =====================================================
        // 5. Penalty: being stuck (very low movement)
        // =====================================================
        if (Math.abs(p.vx) < 0.2 && Math.abs(p.vy) < 0.2) {
            r -= 0.01;
        }

        // =====================================================
        // 6. Reward: open-ice spacing when teammate has puck
        // =====================================================
        if (owner && owner.team === p.team && owner.id !== p.id) {
            const d = Math.hypot(p.x - owner.x, p.y - owner.y);
            if (d > 40) r += 0.02;
        }

        // accumulate reward
        p.reward += r;
    }
}




// =========================================================
// TRAINING TICK (Phase 2)
// =========================================================
function trainingTick(now) {
    // Only active during training mode
    TRAIN_STEPS++;

    // --- possession tracking ---
    const owner = getPlayerById(puck.ownerId);
    if (owner) {
        if (owner.team === 0) TRAIN_POS_T0++;
        else TRAIN_POS_T1++;
    } else {
        TRAIN_POS_NONE++;
    }

    // Steps-per-second calculation
    if (now - TRAIN_LAST_TIME >= 1000) {
        TRAIN_SPS = TRAIN_STEPS - (TRAIN_LAST_TIME_STEPS || 0);
        TRAIN_LAST_TIME_STEPS = TRAIN_STEPS;
        TRAIN_LAST_TIME = now;
    }

    applyTrainingRewards();
}


let fps = 0;
let frameCount = 0;
let lastTime = performance.now();

const resizeCanvas = () => {
    const aspect = 1000 / 600;
    let newW = window.innerWidth;
    let newH = window.innerHeight;
    
    if (newW / newH > aspect) {
        newW = newH * aspect;
    } else {
        newH = newW / aspect;
    }
    
    canvas.style.width = newW + 'px';
    canvas.style.height = newH + 'px';
    canvas.width = 1000;
    canvas.height = 600;
};


// =========================================================
// GAME STATE MANAGEMENT
// =========================================================


let menuAutoStartAt = Date.now() + 4000;   // 4 seconds


function startTraining() {
    // Only schedule if a training loop isn't already running
    if (trainingTimeoutId === null) {
        trainingLoop();
    }
}

function stopTraining() {
    if (trainingTimeoutId !== null) {
        clearTimeout(trainingTimeoutId);
        trainingTimeoutId = null;
    }
}

function startGame(startNewEpisode = false) {


    // If we're starting a fresh training episode
    if (startNewEpisode) {
        TRAINING_MODE = true;
        gameState = 'training';
        resetAfterGoal(-1); // Reset game state
    } else {
        // Resume or Start new Standard Game
        gameState = TRAINING_MODE ? 'training' : 'playing';

        // ðŸ›‘ NEW: Reset game state for a fresh Standard Game
        if (gameState === 'playing') {
            timeRemaining = GAME_DURATION_SECONDS; // Reset clock
            scoreTeam0 = 0; // Reset score
            scoreTeam1 = 0;
            lastGameTimeUpdate = performance.now(); // Reset timer reference
            resetPlayersToSpawn(); 
            goalResetTimer = null;
            startFaceoffPause();

        }
    }

    if (TRAINING_MODE) startTraining();
    else stopTraining();

}

function activateMenuItem(item) {

    if (item === "New Game") {
        startGame(false);
        gameState = "playing";
        return;
    }

    if (item === "Options") {
        // Placeholder â€” stays in menu for now
        return;
    }

    if (item === "Exit") {
        // For browser: reload page
        location.reload();
    }
}

function drawMenu() {
    // Background
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // Title
    ctx.fillStyle = "#fff";
    ctx.font = "40px Arial";
    ctx.fillText("UNIFIED AI HOCKEY", W / 2, 140);

    // Subtitle
    ctx.font = "26px Arial";
    ctx.fillText("MENU", W / 2, 200);

    // Menu items
    ctx.font = "24px Arial";
    for (let i = 0; i < menuItems.length; i++) {
        const y = 280 + i * 40;

        if (i === menuIndex) {
            // highlight box
            ctx.fillStyle = "#2255ff";
            ctx.fillRect(W/2 - 160, y - 20, 320, 36);

            ctx.fillStyle = "#fff";
        } else {
            ctx.fillStyle = "#bbb";
        }

        ctx.fillText(menuItems[i], W / 2, y);
    }

    // Footer hint
    ctx.fillStyle = "#666";
    ctx.font = "16px Arial";
    ctx.fillText("Use â†‘ â†“ to navigate, Enter to select", W / 2, H - 60);
}



// =========================================================
// TEAM GLOBALS
// =========================================================

// =========================================================
// GAME CLOCK AND SCORE GLOBALS
// =========================================================
const GAME_DURATION_SECONDS = 20; // seconds
let timeRemaining = GAME_DURATION_SECONDS;
let lastGameTimeUpdate = performance.now();

let faceoffPauseUntil = 0;   // timestamp in ms

let puckOutMessage = false;       // whether we draw the message
let puckOutMessageUntil = 0;      // when the message expires
let puckOutPauseUntil = 0;        // new simple pause timer
let puckOutResetAt = 0;           // when to actually move players to faceoff

let gameOverAutoStartAt = 0;  // for github only


let scoreTeam0 = 0;
let scoreTeam1 = 0;

let lastGoalTeam = null;

let puckStealCooldown = 0;

let goalieFreezeTimer = 0;

let shootIndicator = "red";   // "red" | "yellow" | "green"
let shootReason = "";

let roleLockTimer = 0;   // frames of role lock (0 = off)

// base uniforms 
const TEAM0_COLOR = "#3392ff";
const TEAM1_COLOR = "#ff6a3c";

// puck-holder = slightly more saturated
const TEAM0_COLOR_HAS_PUCK = "#006deb";  
const TEAM1_COLOR_HAS_PUCK = "#de3b00";  

let DEBUG_ROLES = false;   // set false for normal jerseys


let goalResetTimer = 0;   // frames until puck resets

let ticksSinceLastGoal = 0;
const FAILSAFE_MAX_TICKS = 10000; // adjust based on stepsPerTick







document.addEventListener("keydown", (e) => {
    if (gameState !== "menu") return;

    if (e.key === "ArrowUp") {
        menuIndex = (menuIndex - 1 + menuItems.length) % menuItems.length;
    }
    if (e.key === "ArrowDown") {
        menuIndex = (menuIndex + 1) % menuItems.length;
    }
    if (e.key === "Enter") {
        activateMenuItem(menuItems[menuIndex]);
    }
});


window.addEventListener('resize', resizeCanvas);
resizeCanvas();

document.addEventListener('keydown', e => {
    if (e.key === 'f' || e.key === 'F11') {
        e.preventDefault();
        if (!document.fullscreenElement) {
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            }
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }
});


document.addEventListener("keydown", (e) => {
    if (e.key === 't') {
        TRAINING_MODE = !TRAINING_MODE;
        console.log("TRAINING_MODE =", TRAINING_MODE);

        // when turning training mode ON, restart the training loop
        if (TRAINING_MODE) trainingLoop();
    }
});

document.addEventListener("keydown", e => {
    if (e.key === 'r') {
        TRAIN_RENDER = !TRAIN_RENDER;
        console.log("TRAIN_RENDER =", TRAIN_RENDER);
    }
});

document.addEventListener("keydown", e => {
    if (e.key === 'i') {
        console.log("Inputs for player 1:", buildAIInputs(players[0]));
    }
    if (e.key === 'o') {
        const ins = buildAIInputs(players[0]);
        console.log("Outputs for player 1:", aiForwardPass(ins, players[0].brain));
    }
});

document.addEventListener("keydown", (e) => {
    if (e.key === 'w') {
        WATCH_MODE = !WATCH_MODE;
        console.log("WATCH_MODE:", WATCH_MODE);
    }
});


window.addEventListener("keydown", e => {
    if (e.key === "d") DEBUG_ROLES = !DEBUG_ROLES;
});

document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") {
        gameState = "menu";
        menuIndex = 0;
    }
});


document.addEventListener("keydown", (e) => {
    if (gameState !== "gameover") return;

    if (e.key === "Escape") {
        // ignore ESC to preserve fullscreen
        return;
    }

    // any other key continues to menu
    gameState = "menu";
});



const W = canvas.width;
const H = canvas.height;

// Load rink image
const rinkImg = new Image();
rinkImg.src = "rink_background.png";

// Offscreen buffer
const offscreenCanvas = document.createElement("canvas");
offscreenCanvas.width = W;
offscreenCanvas.height = H;
const offctx = offscreenCanvas.getContext("2d");

// =========================================================
// RINK GEOMETRY
// =========================================================
const RINK_W = 800;
const RINK_H = 340;
const RINK_X = (W - RINK_W) / 2; // 100
const RINK_Y = 150;



const R = 100;
const STEPS = 6;

ctx.imageSmoothingEnabled = false;

// TRUE RINK CENTER
const RX = RINK_X + RINK_W/2; // 500
const RY = RINK_Y + RINK_H/2; // 320


// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// CRITICAL FIX: ALL PLAYER C HELPERS â€” MUST BE HERE
// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
const LEFT_BLUE_LINE  = RX - 110;
const RIGHT_BLUE_LINE = RX + 110;

function getPuckZone(team) {
    if (team === 0) {
        if (puck.x < LEFT_BLUE_LINE)  return 'own';
        if (puck.x > RIGHT_BLUE_LINE) return 'opp';
        return 'neutral';
    } else {
        if (puck.x > RIGHT_BLUE_LINE) return 'own';
        if (puck.x < LEFT_BLUE_LINE)  return 'opp';
        return 'neutral';
    }
}

function getBlueLinePosition(team, puckY) {
    const ownBlueX = (team === 0) ? LEFT_BLUE_LINE + 30 : RIGHT_BLUE_LINE - 30;
    const sideOffset = (puckY < RY ? 1 : -1) * 90;
    return {
        tx: ownBlueX,
        ty: clamp(RY + sideOffset, RINK_MIN_Y + 50, RINK_MAX_Y - 50),
        action: "none"
    };
}

// THIS IS THE ONE THAT WAS MISSING / BROKEN
function lateralClear(p, dir) {
    const testX = p.x + dir * 140;
    for (const o of players) {
        if (o.team === p.team || o.type === "goalie") continue;
        if (Math.abs(o.x - testX) < 80 && Math.abs(o.y - p.y) < 130) {
            return false;
        }
    }
    return true;
}





function buildRinkPolygon() {
    const w = RINK_W, h = RINK_H, r = R, s = STEPS;
    const pts = [];

    pts.push({x:r, y:0});
    pts.push({x:w-r, y:0});

    {   // top-right
        const cx=w-r, cy=r;
        for(let i=1;i<=s;i++){
            const a=1.5*Math.PI + (i/s)*(0.5*Math.PI);
            pts.push({x:cx+Math.cos(a)*r, y:cy+Math.sin(a)*r});
        }
    }

    pts.push({x:w, y:h-r});

    {   // bottom-right
        const cx=w-r, cy=h-r;
        for(let i=1;i<=s;i++){
            const a=(i/s)*(Math.PI/2);
            pts.push({x:cx+Math.cos(a)*r, y:cy+Math.sin(a)*r});
        }
    }

    pts.push({x:w-r, y:h});
    pts.push({x:r,   y:h});

    {   // bottom-left
        const cx=r, cy=h-r;
        for(let i=1;i<=s;i++){
            const a=Math.PI/2 + (i/s)*(Math.PI/2);
            pts.push({x:cx+Math.cos(a)*r, y:cy+Math.sin(a)*r});
        }
    }

    pts.push({x:0, y:h-r});
    pts.push({x:0, y:r});

    {   // top-left
        const cx=r, cy=r;
        for(let i=1;i<=s;i++){
            const a=Math.PI + (i/s)*(Math.PI/2);
            pts.push({x:cx+Math.cos(a)*r, y:cy+Math.sin(a)*r});
        }
    }

    return pts;
}

const rinkPoly = buildRinkPolygon();

// =========================================================
// COMPUTE RINK BOUNDING BOX FROM POLYGON
// =========================================================
let RINK_MIN_X = Infinity;
let RINK_MAX_X = -Infinity;
let RINK_MIN_Y = Infinity;
let RINK_MAX_Y = -Infinity;

for (const pt of rinkPoly) {
    const gx = pt.x + RINK_X;
    const gy = pt.y + RINK_Y;

    if (gx < RINK_MIN_X) RINK_MIN_X = gx;
    if (gx > RINK_MAX_X) RINK_MAX_X = gx;
    if (gy < RINK_MIN_Y) RINK_MIN_Y = gy;
    if (gy > RINK_MAX_Y) RINK_MAX_Y = gy;
}



// Build wall + net segments with precomputed normals
let rinkSegments = [];
for (let i=0;i<rinkPoly.length;i++){
    const p1 = rinkPoly[i];
    const p2 = rinkPoly[(i+1)%rinkPoly.length];
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const len = Math.sqrt(dx*dx + dy*dy);
    rinkSegments.push({
        x1: p1.x + RINK_X,
        y1: p1.y + RINK_Y,
        x2: p2.x + RINK_X,
        y2: p2.y + RINK_Y,
        type: "wall",
        nx: len > 0 ? -dy / len : 0,
        ny: len > 0 ? dx / len : 0,
        len: len
    });
}

// Goals & nets
const goal1 = RX - 325;
const goal2 = RX + 325;
const GOALIE_OFFSET_INSIDE = 18;

const NET_H = 45;
const NET_D = 25;

const topY = RINK_Y + (RY - (NET_H/2) - RINK_Y);
const botY = topY + NET_H;

// LEFT NET
let seg = { x1: goal1 - NET_D, y1: topY, x2: goal1 - NET_D, y2: botY, type:"goal" };
let dx = seg.x2 - seg.x1, dy = seg.y2 - seg.y1, len = Math.sqrt(dx*dx + dy*dy);
seg.nx = len > 0 ? -dy / len : 0;
seg.ny = len > 0 ? dx / len : 0;
seg.len = len;
rinkSegments.push(seg);

seg = { x1: goal1 - NET_D, y1: topY, x2: goal1,         y2: topY, type:"goal" };
dx = seg.x2 - seg.x1; dy = seg.y2 - seg.y1; len = Math.sqrt(dx*dx + dy*dy);
seg.nx = len > 0 ? -dy / len : 0;
seg.ny = len > 0 ? dx / len : 0;
seg.len = len;
rinkSegments.push(seg);

seg = { x1: goal1 - NET_D, y1: botY, x2: goal1,         y2: botY, type:"goal" };
dx = seg.x2 - seg.x1; dy = seg.y2 - seg.y1; len = Math.sqrt(dx*dx + dy*dy);
seg.nx = len > 0 ? -dy / len : 0;
seg.ny = len > 0 ? dx / len : 0;
seg.len = len;
rinkSegments.push(seg);

// RIGHT NET
seg = { x1: goal2 + NET_D, y1: topY, x2: goal2 + NET_D, y2: botY, type:"goal" };
dx = seg.x2 - seg.x1; dy = seg.y2 - seg.y1; len = Math.sqrt(dx*dx + dy*dy);
seg.nx = len > 0 ? -dy / len : 0;
seg.ny = len > 0 ? dx / len : 0;
seg.len = len;
rinkSegments.push(seg);

seg = { x1: goal2,         y1: topY, x2: goal2 + NET_D, y2: topY, type:"goal" };
dx = seg.x2 - seg.x1; dy = seg.y2 - seg.y1; len = Math.sqrt(dx*dx + dy*dy);
seg.nx = len > 0 ? -dy / len : 0;
seg.ny = len > 0 ? dx / len : 0;
seg.len = len;
rinkSegments.push(seg);

seg = { x1: goal2,         y1: botY, x2: goal2 + NET_D, y2: botY, type:"goal" };
dx = seg.x2 - seg.x1; dy = seg.y2 - seg.y1; len = Math.sqrt(dx*dx + dy*dy);
seg.nx = len > 0 ? -dy / len : 0;
seg.ny = len > 0 ? dx / len : 0;
seg.len = len;
rinkSegments.push(seg);

// =========================================================
// INPUT
// =========================================================
const keys = {
    ArrowUp:false,
    ArrowDown:false,
    ArrowLeft:false,
    ArrowRight:false,
    Control:false
};

document.addEventListener("keydown", e => { 
    if (keys[e.key] !== undefined) keys[e.key] = true; 
});
document.addEventListener("keyup",   e => { 
    if (keys[e.key] !== undefined) keys[e.key] = false; 
});

// =========================================================
// UTIL
// =========================================================
function clamp(v, lo, hi) {
    return v < lo ? lo : (v > hi ? hi : v);
}

function normalizeAngle(a) {
    while (a <= -Math.PI) a += 2 * Math.PI;
    while (a >  Math.PI)  a -= 2 * Math.PI;
    return a;
}

function isResetActive() {
    return goalResetTimer && performance.now() < goalResetTimer;
}

function startFaceoffPause() {
    faceoffPauseUntil = performance.now() + 1000; // 1 second
}



// =========================================================
// COLLISIONS (RINK)
// =========================================================
function collideWithRink(obj, radius) {
    for (const s of rinkSegments) {
        if (s.len === 0) continue;

        const dx = obj.x - s.x1;
        const dy = obj.y - s.y1;
        const t = (dx * (s.x2 - s.x1) + dy * (s.y2 - s.y1)) / (s.len * s.len);
        const clamped = Math.max(0, Math.min(1, t));

        const cx = s.x1 + clamped * (s.x2 - s.x1);
        const cy = s.y1 + clamped * (s.y2 - s.y1);

        const nx = obj.x - cx;
        const ny = obj.y - cy;
        const dist2 = nx * nx + ny * ny;

        if (dist2 < radius * radius && dist2 > 0) {
            const dist = Math.sqrt(dist2);
            const unx = nx / dist;
            const uny = ny / dist;

            obj.x = cx + unx * radius;
            obj.y = cy + uny * radius;

            let rest = 0.97;
            if (s.type === "goal") rest = 0.2;

            const dot = obj.vx * unx + obj.vy * uny;
            obj.vx -= (1 + rest) * dot * unx;
            obj.vy -= (1 + rest) * dot * uny;

            return true;
        }
    }
    return false;
}


// =========================================================
// COLLISIONS (PUCK vs WALLS)
// =========================================================
function collideCircleWithRink(obj, radius, restitution = 0.8) {
    let collided = false;

    for (const seg of rinkSegments) {
        const x1 = seg.x1, y1 = seg.y1;
        const x2 = seg.x2, y2 = seg.y2;

        const dx = x2 - x1;
        const dy = y2 - y1;
        const segLen2 = dx * dx + dy * dy;
        if (segLen2 === 0) continue;

        // project point onto segment
        const t = ((obj.x - x1) * dx + (obj.y - y1) * dy) / segLen2;
        const clamped = Math.max(0, Math.min(1, t));
        const cx = x1 + clamped * dx;
        const cy = y1 + clamped * dy;

        const nx = obj.x - cx;
        const ny = obj.y - cy;
        const dist2 = nx * nx + ny * ny;
        const minDist = radius;

        if (dist2 < minDist * minDist && dist2 > 0.000001) {
            const dist = Math.sqrt(dist2);
            const unx = nx / dist;
            const uny = ny / dist;

            // push out to exactly minDist
            obj.x = cx + unx * minDist;
            obj.y = cy + uny * minDist;

            // reflect velocity
            const dot = obj.vx * unx + obj.vy * uny;
            obj.vx = obj.vx - 2 * dot * unx;
            obj.vy = obj.vy - 2 * dot * uny;

            // rink vs goal restitution (same idea as good goalie)
            let rest = restitution;
            if (seg.type === "goal") rest = 0.2;

            obj.vx *= rest;
            obj.vy *= rest;

            collided = true;
            break; // one wall is enough
        }
    }

    return collided;
}


// =========================================================
// UNIFIED PLAYER ARCHITECTURE
// =========================================================
function makePlayer({id, team, type, isHuman, x, y, angle}) {
    const p = {
        id,
        team,
        type,
        isHuman,
        x,
        y,
        angle,
        vx: 0,
        vy: 0,
        size: (type === "goalie") ? 12 : 12,
        maxSpeed: (type === "goalie") ? 1.1 : 2.5,
        turnRate: (type === "goalie") ? 0.0 : 0.06,
        friction: 0.02,
        holdTimer: 0,

        brain: {
            inputSize: 0,
            hiddenSize: 0,
            outputSize: 0,
            w1: null,
            w2: null,
            b1: null,
            b2: null
        },

        reward: 0
    };

    // store spawn locations ONCE
    p.spawnX = x;
    p.spawnY = y;
    p.spawnAngle = angle;

    return p;
}



const players = [];

// Human skater (team 0)
players.push(makePlayer({
    id: 1, team: 0, type: "skater", isHuman: false,
    x: RX - 20, y: RY, angle: 0
}));

// Teammate AI skater (team 0)
players.push(makePlayer({
    id: 2, team: 0, type: "skater", isHuman: false,
    x: RX - 61, y: RY - 90, angle: 0
}));

// Teammate AI skater (team 0)
players.push(makePlayer({
    id: 3, team: 0, type: "skater", isHuman: false,
    x: RX - 60, y: RY + 90, angle: 0
}));

// Opponent AI skater (team 1)
players.push(makePlayer({
    id: 6, team: 1, type: "skater", isHuman: false,
    x: RX + 20, y: RY, angle: Math.PI
}));

// Opponent AI skater (team 1)
players.push(makePlayer({
    id: 7, team: 1, type: "skater", isHuman: false,
    x: RX + 61, y: RY + 90, angle: Math.PI
}));

// Opponent AI skater (team 1)
players.push(makePlayer({
    id: 8, team: 1, type: "skater", isHuman: false,
    x: RX + 60, y: RY - 90, angle: Math.PI
}));

// Goalie Left (team 0)
const g0 = makePlayer({
    id: 11, team: 0, type: "goalie", isHuman: false,
    x: goal1 + GOALIE_OFFSET_INSIDE,
    y: RY,
    angle: 0
});
g0.homeX = g0.x;   // anchor position
g0.homeY = g0.y;
players.push(g0);

// Goalie Right (team 1)
const g1 = makePlayer({
    id: 12, team: 1, type: "goalie", isHuman: false,
    x: goal2 - GOALIE_OFFSET_INSIDE,
    y: RY,
    angle: Math.PI
});
g1.homeX = g1.x;   // anchor position
g1.homeY = g1.y;
players.push(g1);


// --------------------------------------------------
// PERMANENT ROLES FOR TEAM 0 (NO AUTO UPDATES)
// --------------------------------------------------
for (const p of players) {
    if (p.team === 0 && p.type === "skater") {
        if (p.id === 1) p.role = "A";  // or whichever you want
        if (p.id === 2) p.role = "B";
        if (p.id === 3) p.role = "C";
    }
}


// =========================================================
// SKATER WALL CONSTRAINTS
// =========================================================
function enforcePlayerWalls(p) {
    const r = p.size;

    if (p.x < RINK_MIN_X + r) {
        p.x = RINK_MIN_X + r;
        p.vx *= -0.3;
    }

    if (p.x > RINK_MAX_X - r) {
        p.x = RINK_MAX_X - r;
        p.vx *= -0.3;
    }

    if (p.y < RINK_MIN_Y + r) {
        p.y = RINK_MIN_Y + r;
        p.vy *= -0.3;
    }

    if (p.y > RINK_MAX_Y - r) {
        p.y = RINK_MAX_Y - r;
        p.vy *= -0.3;
    }
}

function puckEscapedRink() {
    const r = puck.r;

    return (
        puck.x < RINK_MIN_X - r ||
        puck.x > RINK_MAX_X + r ||
        puck.y < RINK_MIN_Y - r ||
        puck.y > RINK_MAX_Y + r
    );
}


function handlePuckEscape() {

    console.warn("Puck escaped rink â€” resetting.");

    // show message
    puckOutMessage = true;
    puckOutMessageUntil = performance.now() + 2000;

    // schedule the actual faceoff teleport
    puckOutResetAt = puckOutMessageUntil;

    // dedicated pause (NOT the goal-based one)
    puckOutPauseUntil = puckOutMessageUntil + 800;  // total freeze time
}




function getPlayerById(id) {
    return players.find(p => p.id === id) || null;
}



function resetPlayersToSpawn() {
    for (const p of players) {
        p.x = p.spawnX;
        p.y = p.spawnY;
        p.angle = p.spawnAngle;
        p.vx = 0;
        p.vy = 0;
        p.ownerId = null;
        p.reward = 0;
    }

    puck.x = RX;
    puck.y = RY;
    puck.vx = 0;
    puck.vy = 0;
    puck.ownerId = null;
}




// =========================================================
// SINGLE PUCK  â€” with swept-collision anti-tunneling
// =========================================================
const puck = {
    px: RX,
    py: RY,
    x: RX,
    y: RY,
    vx: 0,
    vy: 0,
    r: 1.5,
    ownerId: null,

      update() {
        this.px = this.x;
        this.py = this.y;
        const owner = getPlayerById(this.ownerId);

        // If owned, stick to the blade
        if (owner) {
            const dist = owner.size/2 + this.r + 5;
            this.x = owner.x + Math.cos(owner.angle) * dist;
            this.y = owner.y + Math.sin(owner.angle) * dist;
            this.vx = 0;
            this.vy = 0;
            return;
        }

        const radius = this.r;
        const moveLen = Math.hypot(this.vx, this.vy);

        if (moveLen > 0) {
            // same idea as good-goalie: sub-step based on radius
            const maxStep = radius;
            let steps = Math.ceil(moveLen / maxStep);
            if (steps < 1) steps = 1;

            const stepVX = this.vx / steps;
            const stepVY = this.vy / steps;

            for (let i = 0; i < steps; i++) {
                this.x += stepVX;
                this.y += stepVY;

                // use the good-goalie style wall collision
                const hit = collideCircleWithRink(this, radius, 0.8);
                if (hit) break;   // stop once we hit a wall
            }
        }

        // =====================================================
        // PUCK SCRUM BREAKER (prevents 1v1 deadlock in training)
        // If both teams have at least one skater very close
        // to the puck, inject a small random nudge.
        // =====================================================
        let closeTeam0 = 0;
        let closeTeam1 = 0;

        for (const pl of players) {
            const d = Math.hypot(pl.x - this.x, pl.y - this.y);
            if (d < 22) {
                if (pl.team === 0) closeTeam0++;
                else closeTeam1++;
            }
        }

        // If both sides are contesting â†’ break the stalemate
        if (closeTeam0 > 0 && closeTeam1 > 0) {
            this.vx += (Math.random() - 0.5) * 0.4;
            this.vy += (Math.random() - 0.5) * 0.4;
        }


        // puck friction
        this.vx *= 0.993;
        this.vy *= 0.993;
    },

    draw() {
        ctx.fillStyle = "#000";
        ctx.fillRect(this.x - this.r, this.y - this.r, this.r * 2, this.r * 2);
    }
};

// =========================================================
// POSSESSION HELPERS
// =========================================================
function tryPickupPuck(p) {
    if (isResetActive()) return; 
    if (puck.ownerId !== null) return;

    const dx = puck.x - p.x;
    const dy = puck.y - p.y;
    const pickDist = p.size/2 + puck.r + 5;

    if (dx*dx + dy*dy <= pickDist*pickDist) {
        puck.ownerId = p.id;
        puck.vx = 0;
        puck.vy = 0;
    }
}

function shootPuck(player, power) {
    if (puck.ownerId !== player.id) return;

    puck.ownerId = null;

    const shotPower = power ?? (6 + Math.random() * 3);
    puck.vx = Math.cos(player.angle) * shotPower;
    puck.vy = Math.sin(player.angle) * shotPower;
}


// PASSING SYSTEM â€” Dynamic Lead Calculation
function passPuckToTeammate(p, target) {
    if (puck.ownerId !== p.id) return;

    // 1. Set a crisp pass speed (faster than skating speed)
    const passSpeed = 7.0; 

    // 2. Calculate current distance
    const dist = Math.hypot(target.x - p.x, target.y - p.y);

    // 3. Calculate travel time (frames) = distance / speed
    const travelTime = dist / passSpeed;

    // 4. Predict Future Position
    //    We multiply receiver's velocity by the travel time.
    //    Added a 1.15 multiplier to ensure it lands slightly AHEAD (on the tape), not at the feet.
    let tx = target.x + (target.vx * travelTime * 1.15);
    let ty = target.y + (target.vy * travelTime * 1.15);

    // 5. Safety Clamp (Don't pass into the wall if they are about to crash)
    tx = Math.max(RINK_MIN_X + 20, Math.min(RINK_MAX_X - 20, tx));
    ty = Math.max(RINK_MIN_Y + 20, Math.min(RINK_MAX_Y - 20, ty));

    // 6. Execute Pass toward the predicted spot
    const dx = tx - p.x;
    const dy = ty - p.y;
    const aimDist = Math.hypot(dx, dy);

    if (aimDist < 1) return; // Prevent divide by zero

    puck.ownerId = null;
    puck.vx = (dx / aimDist) * passSpeed;
    puck.vy = (dy / aimDist) * passSpeed;
}




function tryStealPuck(attacker, owner) {
    // already cooling down
    if (puckStealCooldown > 0) return false;

    const dx = attacker.x - owner.x;
    const dy = attacker.y - owner.y;

    const dist2 = dx*dx + dy*dy;
    const stealDist = owner.size/2 + attacker.size/2 + 2;  // must be very close

    if (dist2 < stealDist * stealDist) {
        puck.ownerId = attacker.id;
        puck.vx = 0;
        puck.vy = 0;

        puckStealCooldown = 20;  // ~0.35 seconds at ~60fps
        return true;
    }

    return false;
}

// =========================================================
// PLAYERâ€“PLAYER SOFT COLLISIONS
// =========================================================
function resolvePlayerCollisions() {
    for (let i = 0; i < players.length; i++) {
        for (let j = i + 1; j < players.length; j++) {
            const a = players[i];
            const b = players[j];

            const ar = a.size / 2;
            const br = b.size / 2;
            const minDist = ar + br;

            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist2 = dx*dx + dy*dy;

            if (dist2 < minDist * minDist && dist2 > 0) {
                const dist = Math.sqrt(dist2);
                const overlap = (minDist - dist) * 0.5;

                const nx = dx / dist;
                const ny = dy / dist;

                a.x -= nx * overlap;
                a.y -= ny * overlap;
                b.x += nx * overlap;
                b.y += ny * overlap;
            }
        }
    }
}




// =========================================================
// AI INPUT BUILDER (Phase 3)
// =========================================================
function buildAIInputs(p) {
    const inputs = [];

    // Normalize helpers
    const normX = 1 / W;
    const normY = 1 / H;
    const normV = 1 / 5;   // typical max velocity ~5

    // --- Self velocity ---
    inputs.push(p.vx * normV);
    inputs.push(p.vy * normV);

    // --- Puck relative position ---
    const dxp = puck.x - p.x;
    const dyp = puck.y - p.y;
    const dist_p = Math.hypot(dxp, dyp);

    inputs.push(dxp * normX);
    inputs.push(dyp * normY);
    inputs.push(dist_p * normX);   // normalized distance

    // --- Goals relative ---
    const attackGoalX = (p.team === 0) ? goal2 : goal1;
    const defendGoalX = (p.team === 0) ? goal1 : goal2;

    const dx_ag = attackGoalX - p.x;
    const dy_ag = RY - p.y;

    const dx_dg = defendGoalX - p.x;
    const dy_dg = RY - p.y;

    inputs.push(dx_ag * normX);
    inputs.push(dy_ag * normY);
    inputs.push(dx_dg * normX);
    inputs.push(dy_dg * normY);

    // --- Team puck state ---
    const owner = getPlayerById(puck.ownerId);
    const teammateHas = owner && owner.team === p.team ? 1 : 0;
    const opponentHas = owner && owner.team !== p.team ? 1 : 0;

    inputs.push(teammateHas);
    inputs.push(opponentHas);

    // --- Am I closest teammate to puck? ---
    let closest = true;
    for (const o of players) {
        if (o === p) continue;
        if (o.team !== p.team) continue;
        const d = Math.hypot(o.x - puck.x, o.y - puck.y);
        if (d < dist_p) {
            closest = false;
            break;
        }
    }
    inputs.push(closest ? 1 : 0);

    return inputs;
}



// =========================================================
// AI FORWARD PASS (Phase 3)
// =========================================================
function aiForwardPass(inputs, brain) {
    const { w1, b1, w2, b2 } = brain;

    // tanh activation
    const tanh = x => Math.tanh(x);

    // forward pass: input â†’ hidden
    const hidden = w1.map((row, i) => {
        let sum = b1[i];
        for (let j = 0; j < row.length; j++) {
            sum += row[j] * inputs[j];
        }
        return tanh(sum);
    });

    // forward pass: hidden â†’ output
    const outputs = w2.map((row, i) => {
        let sum = b2[i];
        for (let j = 0; j < row.length; j++) {
            sum += row[j] * hidden[j];
        }
        return tanh(sum);
    });

    // === EXPLORATION NOISE (PHASE 4.4) ===
    const epsilon = 0.2;  // exploration rate (20%)

    for (let i = 0; i < outputs.length; i++) {
        if (Math.random() < epsilon) {
            outputs[i] += (Math.random() * 2 - 1) * 0.5;
            outputs[i] = Math.max(-1, Math.min(1, outputs[i]));  // clamp to [-1, 1]
        }
    }

    return outputs;
}



function updateBrainWithReward(p, learningRate = 0.01) {
    const brain = p.brain;
    const reward = p.reward;

    if (!reward || reward === 0) return;

    function perturb(x, scale = 0.01) {
        return x + (Math.random() * 2 - 1) * scale;
    }

    function updateMatrix(m, scale) {
        for (let i = 0; i < m.length; i++) {
            for (let j = 0; j < m[i].length; j++) {
                m[i][j] += learningRate * reward * (Math.random() * 2 - 1) * scale;
            }
        }
    }

    function updateVector(v, scale) {
        for (let i = 0; i < v.length; i++) {
            v[i] += learningRate * reward * (Math.random() * 2 - 1) * scale;
        }
    }

    updateMatrix(brain.w1, 0.1);
    updateVector(brain.b1, 0.1);
    updateMatrix(brain.w2, 0.1);
    updateVector(brain.b2, 0.1);
}







// =========================================================
// NEURAL NETWORK SETUP (PHASE 4.1)
// =========================================================

function initPlayerBrain(p) {
    const inputSize = buildAIInputs(p).length;
    const hiddenSize = 8;
    const outputSize = 4;

    // Xavier Initialization (roughly)
    function randn(scale) {
        return (Math.random() * 2 - 1) * scale;
    }

    function randMatrix(rows, cols, scale) {
        const m = [];
        for (let i = 0; i < rows; i++) {
            const row = [];
            for (let j = 0; j < cols; j++) {
                row.push(randn(scale));
            }
            m.push(row);
        }
        return m;
    }

    function randVector(size, scale) {
        return Array.from({ length: size }, () => randn(scale));
    }

    const scale1 = Math.sqrt(1 / inputSize);
    const scale2 = Math.sqrt(1 / hiddenSize);

    p.brain.inputSize = inputSize;
    p.brain.hiddenSize = hiddenSize;
    p.brain.outputSize = outputSize;
    p.brain.w1 = randMatrix(hiddenSize, inputSize, scale1);
    p.brain.b1 = randVector(hiddenSize, scale1);
    p.brain.w2 = randMatrix(outputSize, hiddenSize, scale2);
    p.brain.b2 = randVector(outputSize, scale2);
}

// Call on all Team 0 skaters
for (const p of players) {
    if (p.team === 0 && p.type === "skater") {
        initPlayerBrain(p);
    }
}









// =========================================================
// PLAYER UPDATES
// =========================================================
function updateHumanSkater(p) {
    let turn = p.turnRate;
    if (keys.ArrowDown) turn *= 2.2;

    if (keys.ArrowLeft)  p.angle -= turn;
    if (keys.ArrowRight) p.angle += turn;

    if (keys.ArrowUp) {
        const fwd = 0.08;
        p.vx += Math.cos(p.angle) * fwd;
        p.vy += Math.sin(p.angle) * fwd;
    }

    if (keys.ArrowDown) {
        p.vx *= 0.99;
        p.vy *= 0.99;
    } else {
        p.vx *= (1 - p.friction);
        p.vy *= (1 - p.friction);
    }

    if (keys.ArrowLeft || keys.ArrowRight) {
        p.vx *= 0.995;
        p.vy *= 0.995;
    }

    const sp = Math.hypot(p.vx, p.vy);
    if (sp > p.maxSpeed) {
        const s = p.maxSpeed / sp;
        p.vx *= s;
        p.vy *= s;
    }

    p.x += p.vx;
    p.y += p.vy;
    collideWithRink(p, p.size/2);

    // try to pick up free puck
    tryPickupPuck(p);

    // attempt to steal from puck owner
    if (puck.ownerId !== null && puck.ownerId !== p.id) {
        const owner = getPlayerById(puck.ownerId);
        if (owner && owner.team !== p.team) {
            tryStealPuck(p, owner);
        }
    }


    // shoot if we own the puck
    if (keys.Control && puck.ownerId === p.id) {
        shootPuck(p);
    }
}


function isClosestTeammateToPuck(p) {
    const dp = Math.hypot(puck.x - p.x, puck.y - p.y);

    for (const o of players) {
        if (o.team !== p.team) continue;
        if (o === p) continue;

        const d = Math.hypot(puck.x - o.x, puck.y - o.y);
        if (d < dp) return false;
    }
    return true;
}


// ============================================================================
// =========================== AI DECISION MODEL ==============================
// ============================================================================
//
// Each skater evaluates behaviour in this order:
// 1. If I have puck â†’ decideWithPuck()
// 2. If teammate has puck â†’ supportTeammate()
// 3. If opponent has puck â†’ defendAgainstOpponent()
// 4. If puck is loose â†’ chaseLoosePuck()
//
// Each decision function returns:
//   { tx: number, ty: number, action: "none"|"shoot"|"pass", target: player|null }
//
// updateAISkater() will then steer toward tx, ty and perform the action.
// ============================================================================



// ---------------------------------------------------------------------------
// ROLE SYSTEM HELPERS (MUST BE ABOVE think(p))
// ---------------------------------------------------------------------------




function assignRolesForTeam(team) {
    const myGoalX = (team === 0) ? goal1 : goal2;

    const skaters = players.filter(p => p.team === team && p.type === "skater");

    // sort by closeness to own goal
    skaters.sort((a,b) => Math.abs(a.x - myGoalX) - Math.abs(b.x - myGoalX));

    skaters[0].role = "A";
    skaters[1].role = "B";
    skaters[2].role = "C";
}

function getTeamRoles(team) {
    const myGoalX = (team === 0) ? goal1 : goal2;
    let arr = players.filter(p => p.team === team && p.type === "skater");
    arr.sort((a,b) => Math.abs(a.x - myGoalX) - Math.abs(b.x - myGoalX));
    return { closest: arr[0], middle: arr[1], farthest: arr[2] };
}

function roleA_goalieProtector(p) {
    const gx = (p.team === 0) ? goal1 : goal2;
    const gy = RY;
    let opp = null, best = 999999;
    for (const o of players) {
        if (o.team === p.team) continue;
        const d = Math.hypot(o.x - p.x, o.y - p.y);
        if (d < best) { best = d; opp = o; }
    }
    const bx = (opp.x + gx) / 2;
    const by = (opp.y + gy) / 2;
    return { tx: bx, ty: by, action:"none" };
}

function roleB_attack(p) {
    const gx = (p.team === 0) ? goal2 : goal1;
    return { tx: gx, ty: RY, action:"none" };
}

function roleB_pressureCarrier(p, carrier) {
    return { tx: carrier.x, ty: carrier.y, action:"none" };
}

function roleB_loosePuck(p) {
    return { tx: puck.x, ty: puck.y, action:"none" };
}

function roleC_supportOffense(p) {
    const gx = (p.team === 0) ? goal2 : goal1;
    return { tx: gx, ty: RY, action:"none" };
}

function roleC_supportDefense(p) {
    const gx = (p.team === 0) ? goal1 : goal2;
    return { tx: gx, ty: RY, action:"none" };
}

function roleC_loosePuck(p) {
    return { tx: puck.x, ty: puck.y, action:"none" };
}

function getPuckCarrier() {
    if (puck.ownerId === null) return null;
    return getPlayerById(puck.ownerId);
}


function solveBehindNet(p) {
    const goalX = (p.team === 0) ? goal2 : goal1;
    
    // Are we actually behind the goal line?
    const isBehind = (p.team === 0) ? (p.x > goalX - 10) : (p.x < goalX + 10);
    if (!isBehind) return null; // We are in front, let normal logic run

    // 1. LOOK FOR CENTERING PASS (One-Timer)
    // --------------------------------------
    // Scan for teammates in the "Slot" (the dangerous area in front of net)
    // Slot location: In front of goal, centered vertically
    const slotX = (p.team === 0) ? goalX - 120 : goalX + 120; 
    
    for (const mate of players) {
        if (mate.team !== p.team || mate.id === p.id) continue;

        // Is teammate roughly in the slot? (within 100px of the sweet spot)
        const distToSlot = Math.hypot(mate.x - slotX, mate.y - RY);
        
        if (distToSlot < 100) {
            // Check if pass lane is blocked before trying
            if (!isLaneBlocked(p.x, p.y, mate.x, mate.y, p.team)) {
                return { 
                    tx: mate.x, 
                    ty: mate.y, 
                    action: "pass", 
                    target: mate 
                };
            }
        }
    }

    // 2. NO PASS? CURL OUT TO FRONT
    // --------------------------------------
    // If we are on the top half, curl down. If bottom, curl up.
    // We target the "Faceoff Dot" area to get a better angle.
    const curlY = (p.y < RY) ? RY + 40 : RY - 40; 
    const curlX = (p.team === 0) ? goalX - 50 : goalX + 50;

    return { tx: curlX, ty: curlY, action: "none" };
}


// ---------------------------------------------------------------------------
// MASTER DECISION FUNCTION
// ---------------------------------------------------------------------------
function think(p) {
     
    const hasPuck = (p.id === puck.ownerId);
    const carrier = getPuckCarrier();
    const opponentHasPuck = (carrier && carrier.team !== p.team);
    const loose = (puck.ownerId === null);

 

// -----------------------------------------
// ROLE C â€” Primary Attacker / Finisher (ANTI-CHERRY PICK EDITION)
// -----------------------------------------
if (p.role === "C") {

    const hasPuck = (p.id === puck.ownerId);
    const carrier = getPuckCarrier();
    const opponentHasPuck = carrier && carrier.team !== p.team;
    const loose = puck.ownerId === null;

    // Find teammate B
    let teammateB = null;
    for (const mate of players) {
        if (mate.team === p.team && mate.role === "B") {
            teammateB = mate;
            break;
        }
    }

    // =========================================================
    // 1. C HAS THE PUCK
    // =========================================================
    if (hasPuck) {

        // === A. BREAKOUT LOGIC (NEW) ===
        // Triggers if we are behind the Red Line (in our own half)
        const inOwnHalf = (p.team === 0) ? (p.x < RX) : (p.x > RX);
        
        if (inOwnHalf) {
            // 1. LOOK FOR PLAYMAKER B FIRST
            if (teammateB) {
                // Is B ahead of us? (Closer to center ice)
                const bIsAhead = (p.team === 0) ? (teammateB.x > p.x) : (teammateB.x < p.x);
                
                if (bIsAhead) {
                    // Check if pass is clear
                    if (!isLaneBlocked(p.x, p.y, teammateB.x, teammateB.y, p.team)) {
                        return { 
                            tx: teammateB.x, 
                            ty: teammateB.y, 
                            action: "pass", 
                            target: teammateB 
                        };
                    }
                }
            }

            // 2. IF NO PASS, SKATE NORTH (Escape the Zone)
            // Aim for the neutral zone faceoff dot on our side
            const targetX = (p.team === 0) ? RX + 50 : RX - 50;
            const targetY = p.y; // Keep current lane
            
            // Verify the lane straight ahead is clear
            const forwardClear = !isLaneBlocked(p.x, p.y, targetX, targetY, p.team);
            
            if (forwardClear) {
                return { tx: targetX, ty: targetY, action: "none" };
            }
        }
        
        // === B. BEHIND NET CHECK (NEW) ===
        const netMove = solveBehindNet(p); 
        if (netMove) return netMove;

        // === C. OFFENSIVE ZONE ATTACK (Existing Logic) ===
        const goalX = goal2;
        const goalY = RY;

        // --------------------- SHOOT FIRST! ---------------------
        const shot = evaluateShot(p);
        if (shot.good) {
            p.angle = Math.atan2(shot.y - p.y, shot.x - p.x);
            return {
                tx: shot.x,
                ty: shot.y,
                action: "shoot",
                target: null
            };
        }

        // Threat assessment
        let closestDefenderDist = 9999;
        for (const o of players) {
            if (o.team !== p.team && o.type === "skater") {
                const d = Math.hypot(o.x - p.x, o.y - p.y);
                if (d < closestDefenderDist) closestDefenderDist = d;
            }
        }
        const heavilyPressured = closestDefenderDist < 65;

        // Wide-open rush (own/neutral zone)
        if (!heavilyPressured && p.x < RX + 80) {
            const northClear = !isLaneBlocked(p.x, p.y, p.x, p.y - 180, p.team);
            if (northClear) {
                return { tx: p.x, ty: p.y - 160, action: "none" };
            }
        }

        // Offensive zone â†’ cut/drive to net
        if (p.x > RX - 60) {
            if (!isLaneBlocked(p.x, p.y, goalX, goalY, p.team)) {
                return { tx: goalX - 50, ty: goalY, action: "none" };
            }
            const cutY = p.y < RY ? RY + 50 : RY - 50;
            return { tx: goalX - 90, ty: cutY, action: "none" };
        }

        // Give-and-go with B
        if (teammateB && heavilyPressured) {
            const distB = Math.hypot(teammateB.x - p.x, teammateB.y - p.y);
            const clear = !isLaneBlocked(p.x, p.y, teammateB.x, teammateB.y, p.team);
            if (distB < 150 && distB > 50 && clear) {
                return { tx: teammateB.x, ty: teammateB.y, action: "pass", target: teammateB };
            }
        }

        // Cycle east-west
        if (lateralClear(p, +1)) return { tx: p.x + 140, ty: p.y + (Math.random()>0.5?-50:50), action: "none" };
        if (lateralClear(p, -1)) return { tx: p.x - 140, ty: p.y + (Math.random()>0.5?-50:50), action: "none" };

        // Protected dump
        return { tx: goalX - 70, ty: p.y < RY ? RY + 90 : RY - 90, action: "none" };
    }

    // =========================================================
    // 2. NO PUCK â†’ ZONE-AWARE POSITIONING (NEW ANTI-CHERRY PICK!)
    // =========================================================
    const puckZone = getPuckZone(p.team);

    // Teammate B has puck â†’ smart trail
    if (teammateB && teammateB.id === puck.ownerId) {
        if (puckZone === 'own') {
            return getBlueLinePosition(p.team, puck.y);
        }
        // Trail in neutral/opp
        const trailDist = (puckZone === 'neutral') ? 70 : 90;
        const trailAngle = teammateB.angle + Math.PI;
        return {
            tx: teammateB.x + Math.cos(trailAngle) * trailDist,
            ty: teammateB.y + Math.sin(trailAngle) * trailDist,
            action: "none"
        };
    }

    // Loose puck
    if (loose) {
        if (isClosestTeammateToPuck(p)) {  
            return { tx: puck.x, ty: puck.y, action: "none" };
        } else {
            // Zone-aware support
            if (puckZone === 'own') {
                return getBlueLinePosition(p.team, puck.y);
            } else if (puckZone === 'neutral') {
                return { tx: RX + (p.team === 0 ? 30 : -30), ty: RY + (Math.random() > 0.5 ? 70 : -70), action: "none" };
            } else {
                return { tx: RX + (p.team === 0 ? 120 : -120), ty: RY + (Math.random() > 0.5 ? 70 : -70), action: "none" };
            }
        }
    }

    // Opponent has puck â†’ forecheck (respect own zone)
    if (opponentHasPuck) {
        if (puckZone === 'own') {
            return getBlueLinePosition(p.team, carrier.y);
        }
        return { tx: carrier.x, ty: carrier.y, action: "none" };
    }

    // DEFAULT: Zone-aware default position
    if (puckZone === 'own') {
        return getBlueLinePosition(p.team, puck.y);
    } else if (puckZone === 'neutral') {
        return { tx: RX + (p.team === 0 ? 50 : -50), ty: RY + (p.y < RY ? 70 : -70), action: "none" };
    } else {
        return { tx: RX + (p.team === 0 ? 130 : -130), ty: RY + (p.y < RY ? 70 : -70), action: "none" };
    }
}






// -----------------------------------
// ROLE A â€” DEFENSIVE ANCHOR
// -----------------------------------
if (p.role === "A") {
    
    // If Role A has the puck â†’ do NOT skate backward, PASS immediately
    if (hasPuck) {

        // ----------------------------------------------------------------
        // 1. SIMPLE FORWARD PASS (Role A breakout priority)
        // ----------------------------------------------------------------
        let bestMate = null;
        let bestDist = 99999;
 
        for (const t of players) {
            if (t.team !== p.team) continue;
            if (t === p) continue;

            // teammate must be *in front* of Role A (offense direction)
            const forward = (p.team === 0) ? (t.x > p.x) : (t.x < p.x);
            if (!forward) continue;

            const d = Math.hypot(t.x - p.x, t.y - p.y);
            if (d < bestDist) {
                bestDist = d;
                bestMate = t;
            }
        }

        // If ANY teammate is ahead â†’ pass to him (ignore strict rules)
        if (bestMate) {
            return {
                tx: bestMate.x,
                ty: bestMate.y,
                action: "pass",
                target: bestMate
            };
        }

        // ----------------------------------------------------------------
        // 2. Fallback to the original strict pass logic
        // ----------------------------------------------------------------
        const pass = evaluatePassOptions(p);
        if (pass.good) {
            return {
                tx: pass.teammate.x,
                ty: pass.teammate.y,
                action: "pass",
                target: pass.teammate
            };
        }

        // ----------------------------------------------------------------
        // 3. No pass? Move the puck slightly forward
        // ----------------------------------------------------------------
        const safeX = p.x + ((p.team === 0) ? 40 : -40);
        return { tx: safeX, ty: p.y, action: "none" };
    }



        // If puck is loose â†’ chase only if closest
        if (loose) {
            if (isClosestTeammateToTarget(p, puck)) {
                return roleB_loosePuck(p);
            }
            return roleA_goalieProtector(p);
        }

        // If opponent has puck â†’ protect goalie / block threat
        if (opponentHasPuck) {
            return roleA_goalieProtector(p);
        }

        // Teammate has puck:
        // DO NOT join the rush â€” stay deeper than all opponents.
        let lowestOpp = null;
        let bestX = 99999;

        for (const o of players) {
            if (o.team !== p.team && o.type === "skater") {
                if (o.x < bestX) {  // team 0 attacks right, so lowest X = most dangerous
                    bestX = o.x;
                    lowestOpp = o;
                }
            }
        }

        if (lowestOpp) {
            // stay between lowest opponent and our own goalie
            const gx = (p.team === 0) ? goal1 : goal2;
            return {
                tx: (lowestOpp.x + gx) / 2,
                ty: (lowestOpp.y + RY) / 2,
                action: "none"
            };
        }

        // fallback (no opponents?)
        return roleA_goalieProtector(p);
    }


// -----------------------------------------
// ROLE B â€” PLAYMAKER (UPDATED)
// -----------------------------------------
if (p.role === "B") {

    if (hasPuck) {
        // 1. SHOOT IF IN THE SLOT (The "Greedy" Check)
        // ---------------------------------------------------------
        const shot = evaluateShot(p);
        // Take the shot if good, or if we are very close to goal (forcing a rebound)
        if (shot.good || (p.x > goal2 - 100 && Math.abs(p.y - RY) < 40)) { 
             p.angle = Math.atan2(shot.y - p.y, shot.x - p.x);
             return { tx: shot.x, ty: shot.y, action: "shoot", target: null };
        }

        // 2. LOOK FOR SKATER C (The "Killer Pass")
        // ---------------------------------------------------------
        let skaterC = null;
        for (const mate of players) {
            if (mate.team === p.team && mate.role === "C") {
                skaterC = mate;
                break;
            }
        }

        if (skaterC) {
            // Check distance to C (don't pass if he's too close or too far)
            const distC = Math.hypot(skaterC.x - p.x, skaterC.y - p.y);
            
            // Only pass if C is ahead of us (attacking) or we are pinned
            const cIsAhead = (p.team === 0) ? (skaterC.x > p.x) : (skaterC.x < p.x);

            if (distC > 60 && cIsAhead) {
                if (!isLaneBlocked(p.x, p.y, skaterC.x, skaterC.y, p.team)) {
                    return {
                        tx: skaterC.x,
                        ty: skaterC.y,
                        action: "pass",
                        target: skaterC
                    };
                }
            }
        }

        // 3. PRESSURE CHECK (Avoid turnovers)
        // ---------------------------------------------------------
        let covered = false;
        let nearestOppDist = 999;
        for (const o of players) {
            if (o.team === p.team) continue;
            const d = Math.hypot(o.x - p.x, o.y - p.y);
            if (d < nearestOppDist) nearestOppDist = d;
        }
        if (nearestOppDist < 60) covered = true;

        // 4. LATERAL ESCAPE (Renamed from lateralClear to fix crash)
        // ---------------------------------------------------------
        function checkSafeSide(dir) {
            const laneX = p.x + dir * 120;
            const gap  = 40;
            for (const o of players) {
                if (o.team === p.team) continue;
                if (Math.abs(o.x - laneX) < gap && Math.abs(o.y - p.y) < 100) {
                    return false;
                }
            }
            return true;
        }

        // If covered, try to deke sideways before panic passing
        if (covered) {
            if (checkSafeSide(+1)) return { tx: p.x + 100, ty: p.y, action: "none" };
            if (checkSafeSide(-1)) return { tx: p.x - 100, ty: p.y, action: "none" };
            
            // If we can't deke, THEN dump it to whoever is open (likely A)
            const pass = evaluatePassOptions(p);
            if (pass.teammate) {
                return { tx: pass.teammate.x, ty: pass.teammate.y, action: "pass", target: pass.teammate };
            }
        }

        // 5. DRIVE THE NET (Default State)
        // ---------------------------------------------------------
        // If not pressured and no pass to C, carry it forward/center
        return {
            tx: (p.team === 0 ? goal2 : goal1),
            ty: RY, // Drive to center
            action: "none"
        };
    }

    // No puck â†’ existing logic
    if (loose) return roleC_loosePuck(p); // Reuse C's aggression for loose pucks
    if (opponentHasPuck) return roleC_supportDefense(p);
    return roleC_supportOffense(p);
}



}




// ============================================================================
// BEHAVIOUR: WITH PUCK
// ============================================================================
function decideWithPuck(p) {

    const goalX = (p.team === 0) ? goal2 : goal1;

    // Correct vertical center of goal opening
    const goalY = (topY + botY) / 2;

    // =====================================================
    // 1. Evaluate shot
    // =====================================================
    const shoot = evaluateShot(p);

    // BREAKAWAY OVERRIDE = ALWAYS SHOOT
    if (shootReason === "BREAKAWAY â†’ GOOD") {

        // *** Force shooter to face the actual target ***
        p.angle = Math.atan2(shoot.y - p.y, shoot.x - p.x);

        return {
            tx: shoot.x,
            ty: shoot.y,
            action: "shoot",
            target: null
        };
    }

    // NORMAL SHOOT CHECK
    if (shoot.good && !isLaneBlocked(p.x, p.y, shoot.x, shoot.y, p.team)) {

        // *** Force shooter to face target BEFORE shooting ***
        p.angle = Math.atan2(shoot.y - p.y, shoot.x - p.x);

        return {
            tx: shoot.x,
            ty: shoot.y,
            action: "shoot",
            target: null
        };
    }

    // =====================================================
    // 2. Evaluate pass options
    // =====================================================
    const pass = evaluatePassOptions(p);

    if (pass.good) {
        const pressured = isPressured(p);

        const clearLane = !isLaneBlocked(
            p.x, p.y,
            pass.teammate.x, pass.teammate.y,
            p.team
        );

        if (clearLane || pressured) {
            return {
                tx: pass.teammate.x,
                ty: pass.teammate.y,
                action: "pass",
                target: pass.teammate
            };
        }
    }

    // =====================================================
    // 3. Carry puck toward best lane
    // =====================================================
    const lane = pickCarryLane(p);

    return {
        tx: lane.x,
        ty: lane.y,
        action: "none",
        target: null
    };
}






// ============================================================================
// BEHAVIOUR: SUPPORT TEAMMATE WITH PUCK
// ============================================================================
function supportTeammate(p, owner) {

    // How far behind/sideways to be
    const followDist = 70;     // lateral spacing
    const trailDist  = 90;     // trailing support
    
    // Calculate trailing point (behind puck carrier)
    const trailAngle = owner.angle + Math.PI;   // directly behind
    const trailX = owner.x + Math.cos(trailAngle) * trailDist;
    const trailY = owner.y + Math.sin(trailAngle) * trailDist;

    // Calculate lateral point (left/right of puck carrier)
    const leftAngle  = owner.angle + Math.PI/2;
    const rightAngle = owner.angle - Math.PI/2;

    const leftX  = owner.x + Math.cos(leftAngle) * followDist;
    const leftY  = owner.y + Math.sin(leftAngle) * followDist;

    const rightX = owner.x + Math.cos(rightAngle) * followDist;
    const rightY = owner.y + Math.sin(rightAngle) * followDist;

    // Score both lateral sides for openness
    const leftScore  = openSpaceScore(leftX, leftY, p.team);
    const rightScore = openSpaceScore(rightX, rightY, p.team);

    // Choose best position: trail vs left vs right
    let bestX = trailX;
    let bestY = trailY;
    let bestScore = openSpaceScore(trailX, trailY, p.team);

    if (leftScore > bestScore) {
        bestScore = leftScore;
        bestX = leftX;
        bestY = leftY;
    }
    if (rightScore > bestScore) {
        bestScore = rightScore;
        bestX = rightX;
        bestY = rightY;
    }

    return {
        tx: bestX,
        ty: bestY,
        action: "none",
        target: null
    };
}




// ============================================================================
// BEHAVIOUR: DEFEND AGAINST OPPONENT
// ============================================================================
function defendAgainstOpponent(p, owner) {

    const carrier = owner;

    // ----------------------------------------------------------
    // 1. SLOT PROTECTION (default defensive position)
    // ----------------------------------------------------------
    const slotX = (p.team === 0) ? goal1 + 120 : goal2 - 120;
    const slotY = RY;

    // distance from defender to slot
    const distSlot = Math.hypot(p.x - slotX, p.y - slotY);

    // if defender is way out of position â†’ go home first
    if (distSlot > 180) {
        return {
            tx: slotX,
            ty: slotY,
            action: "none"
        };
    }

    // ----------------------------------------------------------
    // 2. CLOSEST DEFENDER â†’ pressure puck carrier
    // ----------------------------------------------------------
    if (isClosestTeammateToTarget(p, carrier)) {

        const dx = carrier.x - p.x;
        const dy = carrier.y - p.y;
        const dist = Math.hypot(dx, dy);

        const idealGap = 110;  // distance you want to maintain

        // too far away â†’ close the gap
        if (dist > idealGap + 40) {
            return {
                tx: carrier.x,
                ty: carrier.y,
                action: "none"
            };
        }

        // too close â†’ back up toward your own net (maintain gap)
        if (dist < idealGap - 40) {
            const retreatX = (p.team === 0) ? goal1 + 60 : goal2 - 60;
            return {
                tx: retreatX,
                ty: p.y,       // same vertical line
                action: "none"
            };
        }

        // ideal gap â†’ shadow the carrier
        return {
            tx: carrier.x - (dx / dist) * idealGap,
            ty: carrier.y - (dy / dist) * idealGap,
            action: "none"
        };
    }

    // ----------------------------------------------------------
    // 3. NOT CLOSEST â†’ block passing lanes
    // ----------------------------------------------------------
    // find the teammate the carrier wants to pass to
    const mate = findBestPassTargetFor(opponentTeam = carrier.team);

    if (mate) {
        // midpoint between carrier and his passing target
        const midX = (carrier.x + mate.x) / 2;
        const midY = (carrier.y + mate.y) / 2;

        return {
            tx: midX,
            ty: midY,
            action: "none"
        };
    }

    // ----------------------------------------------------------
    // 4. fallback = slot protection
    // ----------------------------------------------------------
    return {
        tx: slotX,
        ty: slotY,
        action: "none"
    };
}




// ============================================================================
// BEHAVIOUR: LOOSE PUCK
// ============================================================================
function chaseLoosePuck(p) {

    // closest teammate â†’ chase directly
    if (isClosestTeammateToTarget(p, puck)) {
        return {
            tx: puck.x,
            ty: puck.y,
            action: "none"
        };
    }

    // others â†’ support angle behind closest chaser
    const support = findLoosePuckSupportPosition(p);
    return {
        tx: support.x,
        ty: support.y,
        action: "none"
    };
}



// ============================================================================
// UTILITY HELPERS
// ============================================================================

// Check if this skater is closest teammate to a given target
function isClosestTeammateToTarget(p, target) {
    const myDist = Math.hypot(p.x - target.x, p.y - target.y);

    for (const o of players) {
        if (o.team !== p.team) continue;
        if (o === p) continue;

        const d = Math.hypot(o.x - target.x, o.y - target.y);
        if (d < myDist) return false;
    }

    return true;
}

function isPressured(p) {
    for (const o of players) {
        if (o.team === p.team) continue;
        const d = Math.hypot(o.x - p.x, o.y - p.y);
        if (d < 55) return true;
    }
    return false;
}

function isLaneBlocked(x1, y1, x2, y2, shooterTeam) {
    for (const o of players) {
        // Only opponents of the shooter matter
        if (o.team === shooterTeam) continue;

        const d = pointLineDistance(x1, y1, x2, y2, o.x, o.y);
        if (d < 18) return true;
    }
    return false;
}



function pointLineDistance(x1, y1, x2, y2, px, py) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A*C + B*D;
    const lenSq = C*C + D*D;
    const t = Math.max(0, Math.min(1, dot / lenSq));

    const projX = x1 + t * C;
    const projY = y1 + t * D;

    return Math.hypot(px - projX, py - projY);
}



function findBestPassTargetFor(team) {
    let best = null;
    let bestScore = -999999;

    for (const p of players) {
        if (p.team !== team) continue;     // only that team
        if (p.type !== "skater") continue; // ignore goalie

        // Simple scoring:
        // farther from puck carrier = better passing target
        // more open = better
        const dx = puck.x - p.x;
        const dy = puck.y - p.y;
        const dist = Math.hypot(dx, dy);

        let score = dist;

        // open-space bonus (not near defenders)
        let open = 0;
        for (const o of players) {
            if (o.team === team) continue;
            const d2 = Math.hypot(o.x - p.x, o.y - p.y);
            if (d2 < 100) open -= (100 - d2);  // losing openness
        }
        score += open * 0.5;

        if (score > bestScore) {
            bestScore = score;
            best = p;
        }
    }

    return best;
}





function pickCarryLane(p) {
    const goalX = (p.team === 0) ? goal2 : goal1;
    const offsets = [-80, 0, 80];
    let best = null;
    let bestScore = -999;

    for (let off of offsets) {
        const ly = RY + off;

        // score = how open this lane is
        let score = 0;

        for (const o of players) {
            if (o.team === p.team) continue;
            const d = pointLineDistance(p.x, p.y, goalX, ly, o.x, o.y);
            score += Math.max(0, d - 30);
        }

        if (score > bestScore) {
            bestScore = score;
            best = { x: goalX, y: ly };
        }
    }

    return best;
}


function openSpaceScore(x, y, team) {
    let score = 0;

    for (const o of players) {

        // Opponents = negative
        if (o.team !== team) {
            const d = Math.hypot(o.x - x, o.y - y);
            if (d < 70) score -= (70 - d);   // closer opponent = worse
        }

        // Teammates = mild negative (avoid clustering)
        if (o.team === team) {
            const d = Math.hypot(o.x - x, o.y - y);
            if (d < 40) score -= (40 - d) * 0.3;
        }
    }

    return score;
}


// ---------------------------------------------------------------------------
// Evaluate if shot is possible
// ---------------------------------------------------------------------------
function evaluateShot(p) {
    const goalX = (p.team === 0) ? goal2 : goal1;
    
    // === NEW: STOP SHOOTING FROM BEHIND NET ===
    // If Team 0 (attacking Right), can't shoot if x > goalX
    // If Team 1 (attacking Left), can't shoot if x < goalX
    const behindLine = (p.team === 0) ? (p.x > goalX - 10) : (p.x < goalX + 10);
    
    if (behindLine) {
        shootReason = "BEHIND NET";
        return { good: false, x: goalX, y: RY }; // RY is roughly goal center Y
    }
    // ==========================================
    
    
    const goalY = (topY + botY) / 2;

    shootReason = "";  // default = no reason

    const dx = goalX - p.x;
    const dy = goalY - p.y;
    const dist = Math.hypot(dx, dy);

    // -------------------------------------------------
    // BREAKAWAY OVERRIDE
    // -------------------------------------------------
    let defendersAhead = 0;
    for (const o of players) {
        if (o.team !== p.team && o.type === "skater") {
            if (p.team === 0 && o.x > p.x) defendersAhead++;
            if (p.team === 1 && o.x < p.x) defendersAhead++;
        }
    }

    if (defendersAhead === 0 && dist < 300) {
        shootReason = "BREAKAWAY â†’ GOOD";
        return { good: true, x: goalX, y: goalY };
    }

    // -------------------------------------------------
    // RANGE CHECKS
    // -------------------------------------------------
    if (dist > 150) {
        shootReason = "TOO FAR";
        return { good: false, x: goalX, y: goalY };
    }
    if (dist < 30) {
        shootReason = "TOO CLOSE";
        return { good: false, x: goalX, y: goalY };
    }

    // -------------------------------------------------
    // ANGLE CHECK
    // -------------------------------------------------
    const angle = Math.atan2(dy, dx);
    let diff = Math.abs(normalizeAngle(angle - p.angle));

    if (diff > 2.5) {
        shootReason = "BAD ANGLE";
        return { good: false, x: goalX, y: goalY };
    }

    // -------------------------------------------------
    // BLOCKING CHECK
    // -------------------------------------------------
    if (isLaneBlocked(p.x, p.y, goalX, goalY, p.team)) {
        shootReason = "LANE BLOCKED";
        return { good: false, x: goalX, y: goalY };
    }

    // -------------------------------------------------
    // IN RANGE (final condition)
    // -------------------------------------------------
    const inRange = (dist >= 70 && dist <= 180);
    if (!inRange) {
        shootReason = "OUT OF IDEAL RANGE";
    }

    return {
        good: inRange,
        x: goalX,
        y: goalY
    };
}




// ---------------------------------------------------------------------------
// Choose best pass target
// ---------------------------------------------------------------------------
function evaluatePassOptions(p) {
    let best = null;
    let bestScore = -999;

    for (const t of players) {
        if (t.team !== p.team || t === p) continue;

        // Basic scoring:
        let score = 0;

        // Is he in open ice?
        const open = findOpenIceScore(t);
        score += open;

        // Distance too short or too long? penalize
        const dist = Math.hypot(t.x - p.x, t.y - p.y);
        if (dist < 40) score -= 5;
        if (dist > 350) score -= 5;

        // Opponent pressure near receiver?
        const pressured = isPressured(t);
        if (pressured) score -= 4;

        if (score > bestScore) {
            bestScore = score;
            best = t;
        }
    }

    return {
        good: bestScore > -5,  //experimental to encourage more passes
        teammate: best
    };
}



// ---------------------------------------------------------------------------
// Helpers supporting the above decisions
// ---------------------------------------------------------------------------
function findOpenIce(p) {
    // Move perpendicular to puck direction
    const angle = Math.atan2(p.vy, p.vx) + Math.PI/2;
    return {
        x: Math.cos(angle) * 60,
        y: Math.sin(angle) * 60
    };
}

function findOpenIceScore(p) {
    let score = 0;

    for (const o of players) {
        if (o.team !== p.team) continue;
        const d = Math.hypot(o.x - p.x, o.y - p.y);
        if (d < 50) score -= 2;   // too close to teammate
    }

    return score;
}

function isPressured(p) {
    for (const o of players) {
        if (o.team === p.team) continue;
        const d = Math.hypot(o.x - p.x, o.y - p.y);
        if (d < 50) return true;
    }
    return false;
}

function chooseCarryLane(p) {
    // Aim for enemy goal but slightly off-angle for variety
    const goalX = (p.team === 0) ? goal2 : goal1;
    const goalY = RY + (Math.random()*60 - 30);
    return { x: goalX, y: goalY };
}

function findInterceptionPoint(me, owner) {
    // Stand between puck carrier and our goal
    const goalX = (me.team === 0) ? goal1 : goal2;
    const midX = (owner.x + goalX) / 2;
    return { x: midX, y: RY };
}

function findLoosePuckSupportPosition(p) {
    // Just hang back a bit near center
    return {
        x: RX + (Math.random()*40 - 20),
        y: RY + (Math.random()*40 - 20)
    };
}





function updateAISkater(p) {

    // ======================================================
    // TEAM 0 â†’ USE NEW DECISION MODEL
    // ======================================================
    if (p.team === 0) {

        // 1. Ask the decision system what to do
        const d = think(p);

        // 2. Turn toward desired target
        const dx = d.tx - p.x;
        const dy = d.ty - p.y;
        const desired = Math.atan2(dy, dx);
        let diff = normalizeAngle(desired - p.angle);
        diff = clamp(diff, -p.turnRate * 1.5, p.turnRate * 1.5);
        p.angle += diff;

        // 3. Move forward with the same skating physics you already use
        const accel = 0.07;
        p.vx += Math.cos(p.angle) * accel;
        p.vy += Math.sin(p.angle) * accel;

        p.vx *= (1 - p.friction);
        p.vy *= (1 - p.friction);

        const sp = Math.hypot(p.vx, p.vy);
        if (sp > p.maxSpeed) {
            const s = p.maxSpeed / sp;
            p.vx *= s;
            p.vy *= s;
        }

        p.x += p.vx;
        p.y += p.vy;

        collideWithRink(p, p.size/2);

        // 4. Handle puck interactions
        tryPickupPuck(p);

        if (puck.ownerId !== null && puck.ownerId !== p.id) {
            const owner = getPlayerById(puck.ownerId);
            if (owner && owner.team !== p.team) {
                tryStealPuck(p, owner);
            }
        }

        if (d.action === "shoot" && puck.ownerId === p.id) {
            shootPuck(p);
        }

        if (d.action === "pass" && puck.ownerId === p.id && d.target) {
            passPuckToTeammate(p, d.target); // I'll write this helper for you when you want it
        }

        if (puck.ownerId === p.id) {
            const evalS = evaluateShot(p);

            if (!evalS.good) {
                shootIndicator = "red";
            } else {
                // Distances / angles can still be marginal â†’ "yellow"
                const dx = evalS.x - p.x;
                const dy = evalS.y - p.y;
                const dist = Math.hypot(dx, dy);

                if (dist < 50 || dist > 260) {
                    shootIndicator = "yellow";
                } else {
                    shootIndicator = "green";
                }
            }
        } else {
            shootIndicator = "red"; // only care about puck carrier
        }


        return; // â† TEAM 0 handled, stop here
    }


    // ======================================================
    // TEAM 1 â†’ KEEP YOUR OLD SIMPLE LOGIC EXACTLY AS IS
    // ======================================================
    // Nothing changes for team 1 at all
    const owned = (puck.ownerId === p.id) ? puck : null;

    if (owned) {
        const enemyGoalX = (p.team === 0) ? goal2 : goal1;
        const targetX = enemyGoalX;
        const targetY = RY;

        const dx = targetX - p.x;
        const dy = targetY - p.y;
        const desiredAngle = Math.atan2(dy, dx);

        let diff = normalizeAngle(desiredAngle - p.angle);
        const maxTurn = p.turnRate * 1.5;
        diff = clamp(diff, -maxTurn, maxTurn);
        p.angle += diff;

        const accel = 0.05;
        p.vx += Math.cos(p.angle) * accel;
        p.vy += Math.sin(p.angle) * accel;

        p.vx *= (1 - p.friction);
        p.vy *= (1 - p.friction);

        const sp = Math.hypot(p.vx, p.vy);
        if (sp > p.maxSpeed) {
            const s = p.maxSpeed / sp;
            p.vx *= s;
            p.vy *= s;
        }

        p.x += p.vx;
        p.y += p.vy;
        collideWithRink(p, p.size/2);

        const distToGoal = Math.hypot(targetX - p.x, targetY - p.y);
        if (distToGoal < 140 || Math.random() < 0.01) {
            shootPuck(p);
        }
        return;
    }

    // teammate has puck â†’ support
    const owner = getPlayerById(puck.ownerId);
    if (owner && owner.team === p.team && owner.id !== p.id) {

        const supportOffsetX = Math.cos(owner.angle + Math.PI/2) * 55;
        const supportOffsetY = Math.sin(owner.angle + Math.PI/2) * 55;

        const targetX = owner.x + supportOffsetX;
        const targetY = owner.y + supportOffsetY;

        const dx2 = targetX - p.x;
        const dy2 = targetY - p.y;
        const desiredAngle2 = Math.atan2(dy2, dx2);
        let diff2 = normalizeAngle(desiredAngle2 - p.angle);
        diff2 = clamp(diff2, -p.turnRate * 1.5, p.turnRate * 1.5);
        p.angle += diff2;

        p.vx += Math.cos(p.angle) * 0.04;
        p.vy += Math.sin(p.angle) * 0.04;

        p.vx *= (1 - p.friction);
        p.vy *= (1 - p.friction);

        const sp2 = Math.hypot(p.vx, p.vy);
        if (sp2 > p.maxSpeed) {
            const s2 = p.maxSpeed / sp2;
            p.vx *= s2;
            p.vy *= s2;
        }

        p.x += p.vx;
        p.y += p.vy;
        collideWithRink(p, p.size/2);
        
        return;
    }

    // no one on team has puck: chase puck (simple logic)
    const targetPuck = puck;
    const dx3 = targetPuck.x - p.x;
    const dy3 = targetPuck.y - p.y;
    const desiredAngle3 = Math.atan2(dy3, dx3);
    let diff3 = normalizeAngle(desiredAngle3 - p.angle);
    diff3 = clamp(diff3, -p.turnRate * 1.5, p.turnRate * 1.5);
    p.angle += diff3;

    const dist3 = Math.hypot(dx3, dy3);
    const accel3 = dist3 < 35 ? 0.03 : 0.07;
    p.vx += Math.cos(p.angle) * accel3;
    p.vy += Math.sin(p.angle) * accel3;

    p.vx *= (1 - p.friction);
    p.vy *= (1 - p.friction);

    const sp3 = Math.hypot(p.vx, p.vy);
    if (sp3 > p.maxSpeed) {
        const s3 = p.maxSpeed / sp3;
        p.vx *= s3;
        p.vy *= s3;
    }

    p.x += p.vx;
    p.y += p.vy;
    collideWithRink(p, p.size/2);

    tryPickupPuck(p);

    if (puck.ownerId !== null && puck.ownerId !== p.id) {
        const owner = getPlayerById(puck.ownerId);
        if (owner && owner.team !== p.team) {
            tryStealPuck(p, owner);
        }
    }
}





function updateGoalie(p) {
    const owned = (puck.ownerId === p.id) ? puck : null;

    if (owned) {
        p.holdTimer--;
        const stickDist = p.size / 2 + owned.r + 3;
        owned.x = p.x + Math.cos(p.angle) * stickDist;
        owned.y = p.y + Math.sin(p.angle) * stickDist;
        owned.vx = 0;
        owned.vy = 0;

        if (p.holdTimer <= 0) {
            const targetX = RX;
            const targetY = RY;
            const dx = targetX - p.x;
            const dy = targetY - p.y;
            const randomSpread = (Math.random() * (Math.PI * 0.9)) - (Math.PI * 0.45);
            // base angle toward center ice
            const baseAngle = Math.atan2(RY - p.y, RX - p.x);
            // final angle is base + random offset
            p.angle = baseAngle + randomSpread;
            shootPuck(p, 3 + Math.random() * 2);
        }
        return;
    }

    const watchingPuck = puck;
    const dx = watchingPuck.x - p.x;
    const dy = watchingPuck.y - p.y;

    if ((p.team === 0 && watchingPuck.x < RX) ||
        (p.team === 1 && watchingPuck.x > RX)) {
        let moveY = clamp(dy, -p.maxSpeed, p.maxSpeed);
        p.y += moveY;
    }

    const half = p.size / 2;
    p.y = clamp(p.y, topY + half, botY - half);

    const base = (p.team === 0) ? 0 : Math.PI;
    const desired = Math.atan2(dy, dx);
    let diff = normalizeAngle(desired - base);
    const maxTurn = 1.2;
    diff = clamp(diff, -maxTurn, maxTurn);
    p.angle = base + diff;

//---------------------------------------------------------
// AUTO-RETURN TO HOME X (using velocity, not teleport)
//---------------------------------------------------------
const dxHome = p.homeX - p.x;

// give goalie horizontal velocity toward home
if (Math.abs(dxHome) > 2) {
    p.vx += Math.sign(dxHome) * 0.12;

    // cap sideways speed
    if (p.vx > 1.2) p.vx = 1.2;
    if (p.vx < -1.2) p.vx = -1.2;
} else {
    // near home â†’ damp sideways drift
    p.vx *= 0.85;
}

// apply horizontal velocity
p.x += p.vx;

// clamp inside crease using your actual goal edges
if (p.team === 0) {
    // left goalie: keep to right of left goal post
    const minX = goal1 + p.size/2;
    if (p.x < minX) p.x = minX;
} else {
    // right goalie: keep to left of right goal post
    const maxX = goal2 - p.size/2;
    if (p.x > maxX) p.x = maxX;
}


    // freeze puck if very close and puck is free
    if (watchingPuck.ownerId === null) {
        const dist = Math.hypot(dx, dy);
        const minDist = p.size / 2 + watchingPuck.r + 1;
        if (dist < minDist) {
            watchingPuck.ownerId = p.id;
            watchingPuck.vx = 0;
            watchingPuck.vy = 0;
            p.holdTimer = 30;
            
            // NEW: start freeze timer
            goalieFreezeTimer = performance.now();
        }
    }
       
    
}



function updateAIUsingNN(p) {
    const inputs = buildAIInputs(p);
    const outputs = aiForwardPass(inputs, p.brain);

    // NN Output Order:
    const accel = outputs[0];  // forward thrust
    const brake = outputs[1];  // slow down
    const turnL = outputs[2];  // turn left
    const turnR = outputs[3];  // turn right

    // --- Angle control ---
    if (turnL > 0.1) p.angle -= p.turnRate * turnL;
    if (turnR > 0.1) p.angle += p.turnRate * turnR;

    // --- Velocity control ---
    if (accel > 0.1) {
        const force = accel * 0.08;
        p.vx += Math.cos(p.angle) * force;
        p.vy += Math.sin(p.angle) * force;
    }

    if (brake > 0.1) {
        const factor = 1 - 0.03 * brake;
        p.vx *= factor;
        p.vy *= factor;
    } else {
        p.vx *= (1 - p.friction);
        p.vy *= (1 - p.friction);
    }

    const sp = Math.hypot(p.vx, p.vy);
    if (sp > p.maxSpeed) {
        const s = p.maxSpeed / sp;
        p.vx *= s;
        p.vy *= s;
    }

    p.x += p.vx;
    p.y += p.vy;

    collideWithRink(p, p.size/2);
    tryPickupPuck(p);

    if (puck.ownerId !== null && puck.ownerId !== p.id) {
        const owner = getPlayerById(puck.ownerId);
        if (owner && owner.team !== p.team) {
            tryStealPuck(p, owner);
        }
    }

    if (puck.ownerId === p.id && Math.random() < 0.05) {
        shootPuck(p);
    }
}


function updateCelebration(p) {
    // 1. Slow everyone down (friction)
    p.vx *= 0.9;
    p.vy *= 0.9;

    // 2. Identify where the celebration is
    // Team 0 scores on Goal 2 (Right). Team 1 scores on Goal 1 (Left).
    const celebrationX = (lastGoalTeam === 0) ? goal2 - 120 : goal1 + 120;
    const celebrationY = RY;

    // ===========================================
    // SCORING TEAM: Huddle at the slot
    // ===========================================
    if (p.team === lastGoalTeam) {
        const dx = celebrationX - p.x;
        const dy = celebrationY - p.y;
        const dist = Math.hypot(dx, dy);

        // If far away, skate slowly toward huddle
        if (dist > 30) {
            const angle = Math.atan2(dy, dx);
            p.angle = angle;
            // move at slow "gliding" speed
            p.x += Math.cos(angle) * 1.2;
            p.y += Math.sin(angle) * 1.2;
        } else {
            // If in the huddle, spin slowly in victory
            p.angle += 0.05;
        }
    } 
    // ===========================================
    // LOSING TEAM: Stop and look away in shame
    // ===========================================
    else {
        // If Team 0 lost (Goal 1 conceded), look Right (0) away from net
        // If Team 1 lost (Goal 2 conceded), look Left (PI) away from net
        const shameAngle = (lastGoalTeam === 0) ? Math.PI : 0;

        // Smoothly turn head to shame angle
        let diff = normalizeAngle(shameAngle - p.angle);
        p.angle += diff * 0.1;
        
        // (Velocity is already killed by friction at top)
    }

    // Keep them inside walls
    collideWithRink(p, p.size/2);
}



function updatePlayer(p) {
    
    // === NEW: CELEBRATION OVERRIDE ===
    // If a goal happened and we are waiting for reset:
    if (goalResetTimer > performance.now() && lastGoalTeam !== null) {
        if (p.type === "skater") {
            updateCelebration(p);
            return; // Stop here, don't run normal AI
        }
        // Goalies can just chill (or add goalie shame logic here if you want)
        if (p.type === "goalie") {
             p.vx *= 0.9;
             p.vy *= 0.9;
             return;
        }
    }
    // =================================
    
    
    
    
    if (p.type === "skater") {

        // --- TRAINING MODE OVERRIDE ---
        if (TRAINING_MODE && p.team === 0) {
            updateAIUsingNN(p);
            return;
        }
        if (TRAINING_MODE) {
            updateAISkater(p);
            return;
        }

        // --- PLAY MODE ---
        if (p.isHuman) updateHumanSkater(p);
        else           updateAISkater(p);

        return;
    }

    if (p.type === "goalie") {
        updateGoalie(p);
    }
}


function checkGoalieFreeze() {
    if (puck.ownerId === null) return false;

    const owner = getPlayerById(puck.ownerId);
    if (!owner || owner.type !== "goalie") return false;

    // Time the goalie has held the puck
    const heldMs = performance.now() - goalieFreezeTimer;

    return heldMs > 2000;  // 3 seconds
}



// =========================================================
// CLOCK & SCORE LOGIC (Simplified for Canvas)
// =========================================================
function formatTime(seconds) {
    const min = Math.floor(seconds / 60);
    const sec = Math.floor(seconds % 60);
    const minStr = String(min).padStart(2, '0');
    const secStr = String(sec).padStart(2, '0');
    return `${minStr}:${secStr}`;
}

function updateClock(now) {
    
    const elapsed = (now - lastGameTimeUpdate) / 1000;

    // Check if the game is paused (goal in progress, or in menu/training)
    const isPaused = 
        (goalResetTimer !== null && now < goalResetTimer) || 
        now < faceoffPauseUntil || 
        gameState !== 'playing';

    if (!isPaused && timeRemaining > 0) {
        timeRemaining -= elapsed;
        if (timeRemaining < 0) {
            timeRemaining = 0;
            gameState = "gameover";   // â† END GAME
            gameOverAutoStartAt = Date.now() + 10000;   // restart in 10 seconds
            console.log("Game Over!");
        }
    }
    
    // Crucial: Update the time reference point
    lastGameTimeUpdate = now;
    
    // NOTE: The scoreboard is now updated by drawScoreboard() in renderFrame()
}


// =========================================================
// NEW CANVAS SCOREBOARD DRAWING
// =========================================================
function drawScoreboard() {
    // Determine the center position
    const centerX = W / 2;
    const topMargin = 50;
    const fontHeight = 40;
    
    // Ensure time is formatted (using your existing formatTime helper)
    const timeStr = formatTime(timeRemaining);
    
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // 1. Draw Scores (centered on the clock)
    ctx.font = `bold ${fontHeight}px Arial`;
    
    // Team 0 Score (Left)
    ctx.fillStyle = "#fff"; 
    ctx.fillText(scoreTeam0, centerX - 100, topMargin);
    
    // Team 1 Score (Right)
    ctx.fillStyle = "#fff"; 
    ctx.fillText(scoreTeam1, centerX + 100, topMargin);

    // 2. Draw Clock
    ctx.font = `${fontHeight}px Arial`; // Regular weight
    ctx.fillStyle = "#fff"; // White
    ctx.fillText(timeStr, centerX, topMargin);
}


function drawGameOverOverlay() {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.75)";
    ctx.fillRect(0, 0, W, H);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.fillStyle = "#fff";
    ctx.font = "bold 60px Arial";
    ctx.fillText("GAME OVER", W/2, H/2 - 60);

    let winner;
    if (scoreTeam0 > scoreTeam1) winner = "TEAM 0 WINS!";
    else if (scoreTeam1 > scoreTeam0) winner = "TEAM 1 WINS!";
    else winner = "TIE GAME";

    ctx.font = "40px Arial";
    // ctx.fillText(winner, W/2, H/2 + 10);

    ctx.font = "24px Arial";
    // ctx.fillText("Press ESC for Menu", W/2, H/2 + 70);

    ctx.restore();
}


function handleGameOver(now) {
    // Freeze gameplay but still render
    if (!TRAINING_MODE || WATCH_MODE) {
        renderFrame();
        drawGameOverOverlay();
    }
    requestAnimationFrame(loop);
}




function checkGoal() {
    if (isResetActive()) return;

    const r = puck.r;

    // helper from good-goalie
    function crossedVertLine(lineX) {
        return (puck.px - r > lineX && puck.x - r <= lineX) ||
               (puck.px + r < lineX && puck.x + r >= lineX) ||
               (puck.px + r > lineX && puck.x + r <= lineX) ||
               (puck.px - r < lineX && puck.x - r >= lineX);
    }

    // -----------------------------
    // LEFT GOAL (open on right side)
    // -----------------------------
    const top = topY;
    const bottom = botY;
    const openX = goal1; // the vertical goal-line plane

    const inY = puck.y >= top && puck.y <= bottom;

    if (inY && crossedVertLine(openX) && puck.vx < 0) {
        console.log("GOAL: Team 1 scores on the left net");
        
        // ðŸ›‘ NEW: Increment score for Team 1
        // scoreTeam1++; 
        // ------------------
        
        resetAfterGoal(1);
        return;
    }

    // -----------------------------
    // RIGHT GOAL (open on left side)
    // -----------------------------
    const openX2 = goal2;

    const inY2 = puck.y >= top && puck.y <= bottom;

    if (inY2 && crossedVertLine(openX2) && puck.vx > 0) {
        console.log("GOAL: Team 0 scores on the right net");
        
        // ðŸ›‘ NEW: Increment score for Team 0
        // scoreTeam0++;
        // ------------------
        
        resetAfterGoal(0);
        return;
    }
}





function resetAfterGoal(scoringTeam) {
    // mark who scored for reward logic
    if (scoringTeam !== -1) {
        lastGoalTeam = scoringTeam;
        TRAIN_TOTAL_GOALS++;
    }
    TRAIN_TOTAL_GOALS++;
    goalResetTimer = performance.now() + 6000;

    // Apply reward updates just once per episode
    applyTrainingRewards();  // already computes p.reward

    for (const p of players) {
        if (TRAINING_MODE && p.team === 0 && p.brain && p.brain.w1) {
            updateBrainWithReward(p);
        }
        p.reward = 0;
    }
    
    ticksSinceLastGoal = 0;  // reset the timeout tracker too

}



function doGoalReset() {
    if (lastGoalTeam === 0) scoreTeam0++;
    if (lastGoalTeam === 1) scoreTeam1++;
    lastGoalTeam = null;

    goalResetTimer = null;

    puck.x = RX;
    puck.y = RY;
    puck.vx = 0;
    puck.vy = 0;
    puck.ownerId = null;

    goalieFreezeTimer = 0;

    doFaceoffPositioning();

    startFaceoffPause();
}


function doFaceoffPositioning() {

    for (const p of players) {

        if (p.type === "goalie") {
            p.x = p.homeX;
            p.y = p.homeY;
            p.vx = 0; 
            p.vy = 0;
            p.angle = (p.team === 0 ? 0 : Math.PI);
            continue;
        }

        // Lane detection from spawn positions
        let lane = 0;
        if (p.spawnY < RY - 30) lane = -1;   // TOP
        else if (p.spawnY > RY + 30) lane = 1;  // BOTTOM

        // Slight lane wobble
        const wobbleY = (Math.random() * 20 - 10);

        // Original lane spacing
        const laneSpacing = 90;
        const y = RY + lane * laneSpacing + wobbleY;

        // Center lane players get closer horizontal positions
        const baseOffset = (lane === 0 ? 45 : 80);

        // Random X wobble
        const wobbleX = (Math.random() * 20 - 10);

        const x = (p.team === 0)
            ? RX - (baseOffset + wobbleX)
            : RX + (baseOffset + wobbleX);

        p.x = x;
        p.y = y;

        p.vx = 0;
        p.vy = 0;
        p.angle = (p.team === 0 ? 0 : Math.PI);
    }
}



function drawGoalLights() {
    const r = 12; // Light bulb radius
    // Position lights outside the rink walls (RINK_X is left wall, +RINK_W is right wall)
    const leftX = RINK_X - 30; 
    const rightX = RINK_X + RINK_W + 30; 
    const y = RY;

    // Colors
    const offColor = "#330000"; // Dark maroon
    const onColor = "#ff0000";  // Bright red
    
    // Logic: If Team 1 scores, the puck is in the Left Net -> Left Light ON
    // Logic: If Team 0 scores, the puck is in the Right Net -> Right Light ON
    const isGoalMoment = (goalResetTimer > performance.now()); // currently celebrating
    const leftOn = isGoalMoment && lastGoalTeam === 1;
    const rightOn = isGoalMoment && lastGoalTeam === 0;

    // --- DRAW LEFT LIGHT ---
    ctx.save();
    ctx.beginPath();
    ctx.arc(leftX, y, r, 0, Math.PI*2);
    ctx.fillStyle = leftOn ? onColor : offColor;
    
    if (leftOn) {
        // Glow effect
        ctx.shadowColor = "#ff0000";
        ctx.shadowBlur = 50;
    }
    ctx.fill();
    
    // Grey casing ring
    ctx.shadowBlur = 0; 
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 4;
    ctx.stroke();
    ctx.restore();

    // --- DRAW RIGHT LIGHT ---
    ctx.save();
    ctx.beginPath();
    ctx.arc(rightX, y, r, 0, Math.PI*2);
    ctx.fillStyle = rightOn ? onColor : offColor;
    
    if (rightOn) {
        // Glow effect
        ctx.shadowColor = "#ff0000";
        ctx.shadowBlur = 50;
    }
    ctx.fill();
    
    // Grey casing ring
    ctx.shadowBlur = 0;
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 4;
    ctx.stroke();
    ctx.restore();
}






// =========================================================
// RENDERING FUNCTION (Phase 2)
// =========================================================
function renderFrame() {
    if (!TRAIN_RENDER) return;

    // Stop rendering if menu is open
    if (gameState === 'menu') return;

    // -------------------------------------------------------
    // BASE DRAW LAYER
    // -------------------------------------------------------
    ctx.drawImage(offscreenCanvas, 0, 0);

    drawGoalLights();
    puck.draw();

    for (const p of players) {
        drawPlayer(p);
    }

    // FPS
    // ctx.fillStyle = "#fff";
    // ctx.font = "20px Arial";
    //ctx.fillText(`${fps} FPS`, 10, 30);

    // Scoreboard
    drawScoreboard();


    // ========================================================
    // PUCK OUT OF PLAY MESSAGE
    // ========================================================
    if (puckOutMessage) {
        const now = performance.now();

        if (now < puckOutMessageUntil) {
            // draw message (lower third)
            ctx.fillStyle = "white";
            ctx.textAlign = "center";

            ctx.font = "32px Arial";
            ctx.fillText("PUCK OUT OF PLAY", W/2, H - 80);

            ctx.font = "18px Arial";
            ctx.fillText("Faceoff at center ice", W/2, H - 50);
        } 
    }

    // ========================================================
    // DELAYED FACE-OFF RESET (after message finishes)
    // ========================================================
    if (puckOutResetAt && performance.now() >= puckOutResetAt) {

        // clear flags
        puckOutResetAt = 0;
        puckOutMessage = false;

        // NOW teleport players into faceoff formation
        doFaceoffPositioning();
    }


    // ========================================================
    // TRAINING DISPLAY
    // ========================================================
    if (TRAINING_MODE) {
        ctx.font = "16px Arial";
        ctx.fillText(`EP ${TRAIN_EPISODES}`, 800, 20);
        ctx.fillText(`STEPS ${TRAIN_STEPS}`, 800, 40);
        ctx.fillText(`SPS ${TRAIN_SPS}`, 800, 60);
    }


  
}









// =========================================================
// DRAW
// =========================================================
function drawPlayer(p) {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.angle);

    const half = p.size / 2;

    let bodyColor;
    const hasPuck = (puck.ownerId === p.id);

    // ---------------------------------------------------------
    // DEBUG ROLE COLORS (Team 0 only)
    // ---------------------------------------------------------
    if (DEBUG_ROLES && p.team === 0) {
        // Role-specific debug jersey colors
        if (p.role === "A") bodyColor = "#6529ff";   // PURPLE   = closest to own goalie
        else if (p.role === "B") bodyColor = "#44ff44"; // GREEN = middle
        else if (p.role === "C") bodyColor = "#4488ff"; // BLUE  = farthest from own goalie
        else bodyColor = "#bbbbbb";                   // fallback if no role assigned
    }

    // ---------------------------------------------------------
    // NORMAL GAME COLORS (when debug off OR team 1)
    // ---------------------------------------------------------
    if (!DEBUG_ROLES || p.team !== 0) {
        // TEAM 0
        if (p.team === 0) {
            bodyColor = hasPuck ? TEAM0_COLOR_HAS_PUCK : TEAM0_COLOR;

        // TEAM 1
        } else {
            bodyColor = hasPuck ? TEAM1_COLOR_HAS_PUCK : TEAM1_COLOR;
        }
    }

    // apply jersey color
    ctx.fillStyle = bodyColor;
    ctx.fillRect(-half, -half, p.size, p.size);

    // head (unchanged)
    const head = p.size * 0.4;
    ctx.fillStyle = "#111";
    ctx.fillRect(half - head/2, -head/2, head, head);

    ctx.restore();
}



// =========================================================
// GOAL-BASED EPISODE ENDING (FIXED)
// =========================================================
function trainingAutoEnd() {

    // Prevent multiple endings inside same training tick
    if (!TRAIN_EPISODE_ACTIVE) return;

    // Episode ends after N total goals
    if (TRAIN_TOTAL_GOALS >= TRAIN_GOALS_PER_EPISODE) {

        TRAIN_EPISODE_ACTIVE = false;  // <--- BLOCK re-entry

        console.log("=== EPISODE COMPLETE ===");
        console.log("Episode:", TRAIN_EPISODES);
        console.log("Total Goals:", TRAIN_TOTAL_GOALS);
        console.log("Team 0 Possession:", TRAIN_POS_T0);
        console.log("Team 1 Possession:", TRAIN_POS_T1);
        console.log("No Possession:", TRAIN_POS_NONE);
        console.log("-------------------------");

        TRAIN_EPISODES++;

        // Reset counters
        TRAIN_STEPS = 0;
        TRAIN_TOTAL_GOALS = 0;
        TRAIN_POS_T0 = 0;
        TRAIN_POS_T1 = 0;
        TRAIN_POS_NONE = 0;

        // Reset rink & players
        resetTrainingEpisode();
    }
}


function serializeBrain(brain) {
    return {
        inputSize: brain.inputSize,
        hiddenSize: brain.hiddenSize,
        outputSize: brain.outputSize,
        w1: brain.w1,
        b1: brain.b1,
        w2: brain.w2,
        b2: brain.b2
    };
}

function deserializeBrain(data) {
    return {
        inputSize: data.inputSize,
        hiddenSize: data.hiddenSize,
        outputSize: data.outputSize,
        w1: data.w1,
        b1: data.b1,
        w2: data.w2,
        b2: data.b2
    };
}

function saveAI() {
    const brains = players.filter(p => p.team === 0 && p.brain)
        .map(p => serializeBrain(p.brain));
    document.getElementById("aiStorage").value = JSON.stringify(brains, null, 2);
}

function loadAI() {
    const raw = document.getElementById("aiStorage").value;
    try {
        const brains = JSON.parse(raw);
        const team0 = players.filter(p => p.team === 0 && p.brain);
        for (let i = 0; i < brains.length; i++) {
            if (team0[i]) {
                team0[i].brain = deserializeBrain(brains[i]);
            }
        }
        alert("Brains loaded!");
    } catch (e) {
        alert("Failed to load: " + e.message);
    }
}



// =========================================================
// MAIN LOOP
// =========================================================
function loop(now) {
    frameCount++;
    if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
    }

    // === MENU STATE ===
    if (gameState === 'menu') {

        // Auto-start after timeout
        if (Date.now() >= menuAutoStartAt) {
            startGame();
            gameState = 'playing';
            return requestAnimationFrame(loop);
        }

        // Still in menu â†’ render menu and do nothing else
        drawMenu();
        requestAnimationFrame(loop);
        return;
    }

    // === GAME OVER ===
    if (gameState === 'gameover') {
        
        // AUTO-RESTART TIMER
        if (Date.now() >= gameOverAutoStartAt) {
            TRAINING_MODE = false;
            stopTraining();

            gameState = 'playing';
            resetPlayersToSpawn();
            timeRemaining = GAME_DURATION_SECONDS;
            scoreTeam0 = 0;
            scoreTeam1 = 0;
            lastGameTimeUpdate = performance.now();
            startFaceoffPause();

            return requestAnimationFrame(loop);
        }

        // still in game over â†’ draw screen
        handleGameOver(now);
        requestAnimationFrame(loop);
        return;
    }

    // PAUSE FOR PUCK-OUT-OF-PLAY (simple pause)
    if (performance.now() < puckOutPauseUntil) {
        renderFrame();
        requestAnimationFrame(loop);
        return;
    }


    // === NORMAL GAMEPLAY ===
    if (performance.now() < faceoffPauseUntil) {
        updateClock(now);
        if (!TRAINING_MODE || WATCH_MODE) renderFrame();
        requestAnimationFrame(loop);
        return;
    }

    if (!TRAINING_MODE) {
        puck.update();
        if (puckEscapedRink()) handlePuckEscape();
        if (puckStealCooldown > 0) puckStealCooldown--;
        checkGoal();
        if (checkGoalieFreeze()) resetAfterGoal(-1);
        if (goalResetTimer && performance.now() >= goalResetTimer)
            doGoalReset();

        for (const p of players) {
            updatePlayer(p);
            enforcePlayerWalls(p);
        }

        resolvePlayerCollisions();
    }

    if (!TRAINING_MODE || WATCH_MODE) renderFrame();

    updateClock(now);
    requestAnimationFrame(loop);
}






// =========================================================
// FAST TRAINING LOOP (Phase 4.5)
// =========================================================
function trainingLoop() {
    if (!TRAINING_MODE) return;

    TRAIN_EPISODE_ACTIVE = true;

    // Adjust speed depending on watch mode
    const STEPS_PER_TICK = WATCH_MODE ? 1 : 100;

    // assignRolesForTeam(0);
    // assignRolesForTeam(1);


    for (let i = 0; i < STEPS_PER_TICK; i++) {
        puck.update();
        if (puckEscapedRink()) handlePuckEscape();

        trainingTick(performance.now());
        trainingAutoEnd();

        if (puckStealCooldown > 0) puckStealCooldown--;

        checkGoal();
        if (checkGoalieFreeze()) resetAfterGoal(-1);  
        if (goalResetTimer && performance.now() >= goalResetTimer)
            doGoalReset();

        for (const p of players) {
            updatePlayer(p);
            enforcePlayerWalls(p);
        }

        resolvePlayerCollisions();
    }

    ticksSinceLastGoal++;
    if (ticksSinceLastGoal > FAILSAFE_MAX_TICKS) {
        console.warn("âš ï¸ Failsafe triggered â€” resetting episode.");
        resetAfterGoal(-1);  // Use -1 to signify no team scored
        ticksSinceLastGoal = 0;
    }

    // Schedule next run, with delay if WATCH_MODE is on
    if (gameState !== 'menu') {
        trainingTimeoutId = setTimeout(trainingLoop, WATCH_MODE ? 16 : 0);
    } else {
        trainingTimeoutId = null;
    }
}



rinkImg.onload = () => { // <--- CORRECTED
    offctx.drawImage(rinkImg, 0, 0, W, H);
    // start render loop (60 fps max)
    requestAnimationFrame(loop);
};



</script>




</body>
</html>
